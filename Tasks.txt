Project: AI-Driven Text RPG Bot - Backend Technical Specification (FINAL VERSION with AI CONTEXT MANAGEMENT VIA UI)
Overall Project Context: This is a scalable backend service for a Discord bot supporting numerous independent RPG worlds (per guild). The world is procedurally generated by AI (OpenAI API) and managed by a system of game mechanics (combat, quests, dialogues) based on configurable rules. All data is persistently stored in a scalable DB, isolated for each guild. Multilingual support (RU/EN), NLU input, a Turn System, and Master tools allowing manual situation resolution are supported.

Decomposed Backend Development Task List (For AI Agent - Autonomous Tasks)

Phase 0: Architecture and Initialization (Foundation MVP)
🔧 Task 0.1: Discord Bot Project Initialization and Basic Guild Integration (A-Z Implementation Plan)

**1. Project Setup & Dependencies:**
    *   **Initialize Project Structure:**
        *   Create root directory (e.g., `text_rpg_bot`).
        *   Create `src/` directory for all source code.
        *   Inside `src/`, create:
            *   `bot/`: For Discord bot specific logic.
            *   `core/`: For core game logic (initially might be minimal).
            *   `config/`: For configuration files.
            *   `models/`: For Pydantic/SQLAlchemy models (even if DB is in a later task, basic Pydantic models for config might be here).
            *   `utils/`: For common utility functions.
            *   `main.py`: Entry point for the bot application.
        *   Create `tests/` directory at the root.
        *   Create `requirements.txt` at the root.
        *   Create `.gitignore`.
    *   **Dependencies (`requirements.txt`):**
        *   `discord.py` (or `nextcord`/`disnake` if preferred, assuming `discord.py` for now as per common usage)
        *   `python-dotenv` (for managing environment variables like bot token)
        *   `SQLAlchemy` (even if full DB setup is later, for ORM base models if any config is DB-driven early)
        *   `alembic` (for DB migrations, setup can be done here)
        *   `asyncpg` (or `psycopg2-binary` if PostgreSQL is chosen and synchronous parts exist, but prefer async)
        *   `pydantic` (for data validation and settings management)
        *   Standard logging library (built-in `logging`)
    *   **Environment Configuration (`.env` file):**
        *   `DISCORD_BOT_TOKEN`
        *   `LOG_LEVEL` (e.g., INFO, DEBUG)
        *   (Potentially `DATABASE_URL` if setting up Alembic base)

**2. Configuration System (`src/config/settings.py`):**
    *   Implement a Pydantic `BaseSettings` class to load configuration from environment variables (`.env`) and provide typed access to settings.
    *   Include `DISCORD_BOT_TOKEN`, `LOG_LEVEL`.
    *   Initialize settings instance (e.g., `settings = Settings()`).

**3. Logging Setup (`src/config/logging_config.py` or directly in `main.py` initially):**
    *   Configure a logger using Python's `logging` module.
    *   Set log level based on `settings.LOG_LEVEL`.
    *   Format log messages to include timestamp, level, module name, and message.
    *   Output logs to console. (File logging can be added later if needed).
    *   Example:
        ```python
        # src/config/logging_config.py
        import logging
        from .settings import settings # Assuming settings are accessible

        def setup_logging():
            logging.basicConfig(
                level=settings.LOG_LEVEL.upper(),
                format="%(asctime)s - %(levelname)s - [%(name)s] - %(message)s",
                datefmt="%Y-%m-%d %H:%M:%S"
            )
            # Silence overly verbose discord.py logs if necessary
            # logging.getLogger("discord").setLevel(logging.WARNING)
        ```

**4. Bot Core (`src/bot/core.py` or `main.py`):**
    *   Initialize `discord.Bot` (or `commands.Bot`) instance with necessary intents (e.g., `guilds`, `messages`, `message_content`).
        ```python
        # src/main.py
        import discord
        from discord.ext import commands
        from config.settings import settings
        from config.logging_config import setup_logging
        import logging

        setup_logging()
        logger = logging.getLogger(__name__)

        intents = discord.Intents.default()
        intents.guilds = True
        intents.messages = True
        intents.message_content = True # Required for message content in on_message

        bot = commands.Bot(command_prefix="!", intents=intents) # Or discord.Bot for app commands focus

        @bot.event
        async def on_ready():
            logger.info(f"Bot {bot.user.name} has connected to Discord!")
            logger.info(f"Guilds: {[guild.name for guild in bot.guilds]}")
            # For slash commands, ensure they are synced
            # await bot.tree.sync() # If using app_commands.Bot or discord.Bot
            # logger.info("Commands synced.")

        # ... other event handlers and command loading ...

        if __name__ == "__main__":
            if not settings.DISCORD_BOT_TOKEN:
                logger.error("DISCORD_BOT_TOKEN not found in environment variables.")
            else:
                bot.run(settings.DISCORD_BOT_TOKEN)
        ```

**5. Basic Event Handlers (`src/bot/events.py` or directly in `main.py`/`core.py`):**
    *   **`on_ready`:**
        *   Log bot connection status, username, and list of connected guilds.
        *   If using slash commands, sync the command tree: `await bot.tree.sync()`.
    *   **`on_message(message: discord.Message)`:**
        *   Log basic message info (author, guild, channel, content).
        *   Ignore messages from the bot itself.
        *   (Initially, no command processing here if focusing on slash commands. If using prefix commands, basic parsing could be added).
    *   **`on_guild_join(guild: discord.Guild)`:**
        *   Log that the bot has joined a new guild (guild name, ID).
        *   *(Future Task 0.2/1.1 integration: This is where initial guild configuration in DB would happen, e.g., creating `GuildConfig` entry, populating default static locations if any).*
    *   **`on_guild_remove(guild: discord.Guild)`:**
        *   Log that the bot has been removed from a guild.
        *   *(Future Task: Mark guild data as inactive or schedule for cleanup in DB).*

    ```python
    # Example structure in src/bot/events.py
    # import discord
    # import logging
    # logger = logging.getLogger(__name__)

    # async def on_message_handler(message: discord.Message, bot_user):
    #     if message.author == bot_user:
    #         return
    #     logger.debug(f"Message from {message.author} in {message.guild.name if message.guild else 'DM'}: {message.content}")

    # async def on_guild_join_handler(guild: discord.Guild):
    #     logger.info(f"Joined new guild: {guild.name} (ID: {guild.id})")
    #     # Placeholder for GuildConfig creation
    #     # await setup_guild_config(guild.id)

    # async def on_guild_remove_handler(guild: discord.Guild):
    #     logger.info(f"Removed from guild: {guild.name} (ID: {guild.id})")

    # def setup_event_handlers(bot: commands.Bot):
    #     @bot.event
    #     async def on_message(message: discord.Message):
    #         await on_message_handler(message, bot.user)

    #     @bot.event
    #     async def on_guild_join(guild: discord.Guild):
    #         await on_guild_join_handler(guild)

    #     @bot.event
    #     async def on_guild_remove(guild: discord.Guild):
    #         await on_guild_remove_handler(guild)
    ```
    *Then call `setup_event_handlers(bot)` in `main.py`.*

**6. Utility Commands (`src/bot/commands/general_commands.py`):**
    *   Create a new Cog for general/utility commands.
    *   **`/ping` command (Application Command / Slash Command):**
        *   Responds with "Pong!" and the bot's latency.
        *   Example:
            ```python
            # src/bot/commands/general_commands.py
            import discord
            from discord.ext import commands
            from discord import app_commands # For slash commands
            import logging

            logger = logging.getLogger(__name__)

            class GeneralCog(commands.Cog):
                def __init__(self, bot: commands.Bot):
                    self.bot = bot

                @app_commands.command(name="ping", description="Responds with the bot's latency.")
                async def ping(self, interaction: discord.Interaction):
                    latency_ms = round(self.bot.latency * 1000)
                    await interaction.response.send_message(f"Pong! Latency: {latency_ms}ms")
                    logger.info(f"/ping command executed by {interaction.user} in guild {interaction.guild_id}. Latency: {latency_ms}ms")

            async def setup(bot: commands.Bot):
                await bot.add_cog(GeneralCog(bot))
                logger.info("GeneralCog loaded.")
            ```
    *   Load this Cog in `main.py`:
        ```python
        # In main.py, before bot.run()
        # async def load_extensions():
        #    await bot.load_extension("bot.commands.general_commands")
        # asyncio.run(load_extensions()) # Or within an async main function
        # More robustly:
        # async def main_async():
        #     async with bot:
        #         await bot.load_extension("bot.commands.general_commands")
        #         await bot.start(settings.DISCORD_BOT_TOKEN)
        # if __name__ == "__main__":
        #    asyncio.run(main_async())
        ```
        A simpler way for initial setup in `main.py`:
        ```python
        # In main.py
        # @bot.event
        # async def setup_hook(): # setup_hook is called after login but before on_ready
        #    logger.info("Running setup_hook...")
        #    try:
        #        await bot.load_extension("bot.commands.general_commands")
        #        logger.info("Successfully loaded general_commands extension.")
        #    except Exception as e:
        #        logger.error(f"Failed to load general_commands extension: {e}", exc_info=True)
        #    # For slash commands, ensure they are synced after loading cogs
        #    # This might be better in on_ready if cogs can be loaded/unloaded dynamically
        #    # or if bot.tree.sync is guild-specific in some cases.
        #    # Global sync:
        #    # await bot.tree.sync()
        #    # logger.info("Command tree synced globally.")
        ```
        *Self-correction: `setup_hook` is a good place for initial cog loading. Global command sync is usually fine in `on_ready` or `setup_hook` after cogs are loaded.*

**7. Language System (Basic Placeholder):**
    *   While full i18n is complex, for this initial task, ensure any user-facing strings (like in `/ping` or log messages meant for GMs if any) are identifiable.
    *   A very simple approach for now: constants or a simple dict.
        ```python
        # src/bot/localization.py (very basic)
        # STRINGS = {
        #     "en": {"PONG_RESPONSE": "Pong! Latency: {latency}ms"},
        #     "ru": {"PONG_RESPONSE": "Понг! Задержка: {latency}мс"}
        # }
        # def get_text(key, lang="en", **kwargs):
        #     return STRINGS.get(lang, STRINGS["en"]).get(key, key).format(**kwargs)
        ```
    *   The `/ping` command could use this, but for simplicity in Task 0.1, hardcoded English is acceptable, with a note to integrate a proper localization system later (as per Task 0.3 for `RuleConfig` and further for general text).

**8. Testing Considerations (Conceptual for this stage):**
    *   **Unit Tests:**
        *   Test configuration loading (`config/settings.py`).
        *   Test basic Cog loading.
        *   Test the `/ping` command logic (mocking `discord.Interaction` and `bot.latency`).
    *   **Integration Tests (Manual for now):**
        *   Run the bot.
        *   Invite to a test server.
        *   Verify `on_ready`, `on_guild_join` logs.
        *   Send messages and check `on_message` logs.
        *   Execute `/ping` and verify response.
        *   Remove from server and check `on_guild_remove` logs.
Result: Basic working Discord bot, configured for multiple guilds, logging, language system.


💾 Task 0.2: DBMS Setup and Database Model Definition with Guild ID (A-Z Implementation Plan)

**1. Technology Selection & Setup:**
    *   **DBMS:** PostgreSQL (Chosen for scalability, JSONB support, robustness).
    *   **ORM:** SQLAlchemy (Asynchronous with `asyncpg`).
    *   **Migration Tool:** Alembic.
    *   **Dependencies (add to `requirements.txt` if not already present):**
        *   `sqlalchemy[asyncio]`
        *   `asyncpg`
        *   `alembic`
        *   `psycopg2-binary` (often needed by Alembic even for async projects, or for initial sync DB operations)
        *   `greenlet` (sometimes needed by Alembic with async SQLAlchemy)
    *   **Environment Configuration (add to `.env`):**
        *   `DATABASE_URL="postgresql+asyncpg://user:password@host:port/dbname"`
        *   `SYNC_DATABASE_URL="postgresql+psycopg2://user:password@host:port/dbname"` (for Alembic)

**2. Database Connection & Session Management (`src/core/database.py`):**
    *   Define `async_engine` using `create_async_engine` from `sqlalchemy.ext.asyncio`.
    *   Define `AsyncSessionLocal` using `sessionmaker` from `sqlalchemy.orm`, configured for asynchronous sessions.
    *   Define `Base = declarative_base()` from `sqlalchemy.orm`.
    *   Implement an asynchronous dependency for FastAPI-style session management (or a simple context manager if not using FastAPI yet):
        ```python
        # src/core/database.py
        from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
        from sqlalchemy.orm import sessionmaker, declarative_base
        from config.settings import settings # Assuming settings.DATABASE_URL

        DATABASE_URL = settings.DATABASE_URL
        async_engine = create_async_engine(DATABASE_URL, echo=settings.DB_ECHO) # Add DB_ECHO to settings

        AsyncSessionLocal = sessionmaker(
            bind=async_engine, class_=AsyncSession, expire_on_commit=False
        )

        Base = declarative_base()

        async def get_db_session() -> AsyncSession:
            async with AsyncSessionLocal() as session:
                yield session
        ```

**3. Alembic Initialization & Configuration:**
    *   Run `alembic init alembic` in the project root.
    *   Modify `alembic/env.py`:
        *   Import `Base` from `src.core.database`.
        *   Set `target_metadata = Base.metadata`.
        *   Configure `sqlalchemy.url` to use `settings.SYNC_DATABASE_URL`.
    *   Modify `alembic.ini`:
        *   Set `sqlalchemy.url = %(SYNC_DATABASE_URL)s` (or directly if not using env vars here).

**4. Base Model Definition (`src/models/base.py` or within `src/core/database.py`):**
    *   Define a base class for all models that includes common fields like `id` (PK, Integer, autoincrement) and potentially `created_at`, `updated_at` timestamps.
        ```python
        # src/models/base_model.py (or similar name)
        from sqlalchemy import Column, Integer, DateTime, func
        from sqlalchemy.orm import declared_attr
        from core.database import Base # Assuming Base is in core.database

        class BaseModel(Base):
            __abstract__ = True

            id = Column(Integer, primary_key=True, index=True, autoincrement=True)

            @declared_attr
            def __tablename__(cls):
                return cls.__name__.lower() + "s" # e.g., GuildConfig -> guildconfigs

        class TimestampMixin: # Can be mixed into models needing timestamps
            created_at = Column(DateTime, default=func.now(), nullable=False)
            updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)
        ```

**5. `GuildConfig` Model Definition (`src/models/guild.py`):**
    *   Implement the `GuildConfig` SQLAlchemy model inheriting from `BaseModel` (and `TimestampMixin` if used).
    *   Fields:
        *   `id: Mapped[int] = mapped_column(BigInteger, primary_key=True, index=True, autoincrement=False)` (Discord Guild ID itself)
        *   `master_channel_id: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)`
        *   `system_channel_id: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)`
        *   `notification_channel_id: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)`
        *   `main_language: Mapped[str] = mapped_column(String(10), default="en", nullable=False)`
        *   `supported_languages_json: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True)` (e.g., `["en", "ru"]`)
        *   `is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)` (Useful for soft deletes or marking inactive guilds)
    *   Relationships (placeholders for now, will be defined by other models):
        *   `players: Mapped[List["Player"]] = relationship(back_populates="guild")` (Illustrative)
        *   `locations: Mapped[List["Location"]] = relationship(back_populates="guild")` (Illustrative)
        *   ... and so on for all guild-specific models.
    ```python
    # src/models/guild.py
    from sqlalchemy import Column, BigInteger, String, JSON, Boolean
    from sqlalchemy.orm import Mapped, mapped_column, relationship
    from typing import List, Optional
    # from .base_model import BaseModel, TimestampMixin # Assuming base_model.py
    from core.database import Base # If BaseModel is not separate

    # Assuming BaseModel and TimestampMixin are defined elsewhere or Base directly
    class GuildConfig(Base): # Replace Base with BaseModel if using it
        __tablename__ = "guild_configs" # Explicit table name

        id: Mapped[int] = mapped_column(BigInteger, primary_key=True, index=True, autoincrement=False)
        master_channel_id: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)
        system_channel_id: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)
        notification_channel_id: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)
        main_language: Mapped[str] = mapped_column(String(10), default="en", nullable=False)
        supported_languages_json: Mapped[Optional[List[str]]] = mapped_column(JSON, nullable=True) # JSONB for PostgreSQL in Alembic
        is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)

        # Example relationships (actual definitions will be in other models)
        # players: Mapped[List["Player"]] = relationship(back_populates="guild_config")
        # rule_configs: Mapped[List["RuleConfig"]] = relationship(back_populates="guild_config")
        # ... other relationships

        def __repr__(self):
            return f"<GuildConfig(id={self.id}, main_language='{self.main_language}')>"
    ```
    *Note: Use `JSON` type from `sqlalchemy.types` for general JSON. For PostgreSQL specific `JSONB`, you'd use `from sqlalchemy.dialects.postgresql import JSONB` in the model and migration.*

**6. Placeholder Model Definitions (Initial Structure):**
    *   For each model listed in the task description (Player, Location, WorldState (which might be `RuleConfig` entries), Party, etc.), create basic placeholder files in `src/models/` (e.g., `player.py`, `location.py`).
    *   Each placeholder model should:
        *   Inherit from `BaseModel` (or `Base`).
        *   Include `guild_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("guild_configs.id"), index=True, nullable=False)`.
        *   Include a relationship back to `GuildConfig`: `guild_config: Mapped["GuildConfig"] = relationship(back_populates="<plural_model_name>")`.
        *   Include basic `id` (from `BaseModel`) and a `name_i18n: Mapped[Optional[Dict[str, str]]] = mapped_column(JSONB, nullable=True)` if applicable (as most text fields are i18n).
        *   Include any other immediately obvious critical fields mentioned for specific models if easy.
    *   **Example `src/models/player.py` (placeholder):**
        ```python
        from sqlalchemy import Column, BigInteger, String, ForeignKey, JSON
        from sqlalchemy.orm import Mapped, mapped_column, relationship
        from typing import TYPE_CHECKING, Optional, Dict
        # from .base_model import BaseModel
        from core.database import Base # If BaseModel is not separate

        if TYPE_CHECKING:
            from .guild import GuildConfig # Ensure GuildConfig is defined

        class Player(Base): # Replace Base with BaseModel
            __tablename__ = "players"

            id: Mapped[int] # From BaseModel or define here
            guild_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("guild_configs.id"), index=True, nullable=False)
            discord_user_id: Mapped[int] = mapped_column(BigInteger, unique=True, index=True, nullable=False) # Assuming unique per bot
            name: Mapped[str] = mapped_column(String(100), nullable=False)
            # name_i18n: Mapped[Optional[Dict[str, str]]] = mapped_column(JSON, nullable=True) # Placeholder for i18n name

            # guild_config: Mapped["GuildConfig"] = relationship(back_populates="players")

            def __repr__(self):
                return f"<Player(id={self.id}, name='{self.name}', guild_id={self.guild_id})>"
        ```
        *Self-correction: `guild_config` relation in `Player` should match `back_populates` in `GuildConfig`. E.g., if `GuildConfig` has `players: Mapped[List["Player"]] = relationship(back_populates="guild_config")`, then `Player` has `guild_config: Mapped["GuildConfig"] = relationship(back_populates="players")`.*

    *   **Key Models to create placeholders for (with `guild_id` and `_i18n` fields where text is involved):**
        *   `Player`
        *   `Location`
        *   `RuleConfig` (Note: `key` and `value_json` are primary, `guild_id` links it)
        *   `Party`
        *   `GeneratedNpc`
        *   `GeneratedFaction`
        *   `GeneratedQuest`, `QuestStep`, `Questline`
        *   `Item`, `InventoryItem`
        *   `StoryLog`
        *   `Relationship`
        *   `PlayerNpcMemory` (and `PartyNpcMemory` if planned)
        *   `Ability`, `Skill`, `StatusEffectDefinition` (statuses might be global or guild-specific)
        *   `MobileGroup`, `CraftingRecipe`

**7. Create Initial Alembic Migration:**
    *   Ensure all new model files are imported in `src/models/__init__.py` so Alembic can detect them (e.g., `from .guild import GuildConfig`, `from .player import Player`, etc.).
    *   Run `alembic revision -m "create_initial_game_models"` (or a more descriptive name).
    *   Edit the generated migration file:
        *   Verify that `op.create_table()` calls are generated for all new models.
        *   Ensure `guild_id` columns have ForeignKeys to `guild_configs.id`.
        *   Ensure `JSONB` is used for `_i18n` fields and other JSON fields on PostgreSQL (e.g., `sa.Column('name_i18n', postgresql.JSONB(astext_type=sa.Text()), nullable=True)`).
        *   Add necessary indexes, especially on `guild_id` and any `static_id` or other frequently queried fields.
    *   Run `alembic upgrade head` to apply the migration to the database.

**8. Testing Considerations (Conceptual for this stage):**
    *   **Unit Tests:**
        *   Test creation of `GuildConfig` model instances.
        *   Test creation of placeholder model instances, ensuring `guild_id` is present.
    *   **Integration Tests (Manual for now):**
        *   Verify database schema matches models after running migrations.
        *   Connect to the DB and manually insert/query a `GuildConfig` record.
Result: DB schema is ready for full data isolation by guild and storing all types of game data with multilingual support.


🔧 Task 0.3: Basic DB Interaction Utilities and Rule Configuration Access (Guild-Aware) (A-Z Implementation Plan)

**1. ORM Session Management (`src/core/database.py`):**
    *   **`get_db_session()`:** This function (already defined in Task 0.2) serves as the primary utility for obtaining an `AsyncSession`.
        ```python
        # src/core/database.py - (Ensure this is as defined in Task 0.2)
        # ...
        # async def get_db_session() -> AsyncSession:
        #     async with AsyncSessionLocal() as session:
        #         yield session
        ```
    *   **Transactional Decorator/Context Manager (`src/core/database.py` or `src/utils/transaction.py`):**
        *   Implement `@transactional` decorator for service layer functions that need atomic operations.
        *   It should automatically handle `session.begin()`, `session.commit()`, and `session.rollback()` on exception.
        *   It should inject the `AsyncSession` into the decorated function if not already provided or manage it internally.
        *   **Crucial**: The decorator itself does not enforce `guild_id` filtering; this must be done by the CRUD methods called within the transaction.
        ```python
        # src/utils/transaction.py
        import functools
        import logging
        from sqlalchemy.ext.asyncio import AsyncSession
        from core.database import AsyncSessionLocal # Or get_db_session if it returns a new session

        logger = logging.getLogger(__name__)

        def transactional(func):
            @functools.wraps(func)
            async def wrapper(*args, **kwargs):
                # Attempt to find an existing session in kwargs or args
                session_in_args = next((arg for arg in args if isinstance(arg, AsyncSession)), None)
                session_in_kwargs = kwargs.get("session") # Assuming 'session' kwarg

                db_session: Optional[AsyncSession] = session_in_kwargs or session_in_args

                if db_session: # Session provided by caller, caller manages transaction
                    return await func(*args, **kwargs)
                else: # No session provided, manage transaction here
                    async with AsyncSessionLocal() as new_session:
                        async with new_session.begin(): # Begin transaction
                            try:
                                # Inject session if the function expects it
                                if "session" in func.__code__.co_varnames:
                                    kwargs["session"] = new_session
                                result = await func(*args, **kwargs)
                                # new_session.commit() is handled by 'async with new_session.begin()'
                                return result
                            except Exception as e:
                                logger.error(f"Transaction rolled back due to error in {func.__name__}: {e}", exc_info=True)
                                # await new_session.rollback() # Handled by 'async with new_session.begin()'
                                raise
            return wrapper
        ```

**2. Generic CRUD Utilities (`src/core/crud_base.py`):**
    *   Define a `CRUDBase` class template for SQLAlchemy models.
    *   **Constructor:** Takes a SQLAlchemy model class (`Type[ModelType]`).
    *   **Methods (all asynchronous, taking `session: AsyncSession`):**
        *   `async get(self, session: AsyncSession, id: Any) -> Optional[ModelType]`
        *   `async get_by_guild(self, session: AsyncSession, *, id: Any, guild_id: int) -> Optional[ModelType]`:
            *   Queries for an entity by its `id` AND `guild_id`. Only applicable if model has `guild_id`.
        *   `async get_multi(self, session: AsyncSession, *, skip: int = 0, limit: int = 100) -> List[ModelType]`
        *   `async get_multi_by_guild(self, session: AsyncSession, *, guild_id: int, skip: int = 0, limit: int = 100) -> List[ModelType]`:
            *   Queries for multiple entities, filtered by `guild_id`.
            *   Handles pagination (`skip`, `limit`).
        *   `async create(self, session: AsyncSession, *, obj_in: CreateSchemaType) -> ModelType`:
            *   Takes a Pydantic schema (`CreateSchemaType`) for input data.
            *   Converts schema to dict, creates model instance, adds to session, commits (or relies on `@transactional`), refreshes.
            *   **Crucial**: If `obj_in` contains `guild_id`, it must be used. If the model inherently requires `guild_id` but `obj_in` doesn't provide it (e.g. if `guild_id` comes from context), this method or its caller must ensure `guild_id` is set. For `CRUDBase`, it's safer to assume `guild_id` is part of `obj_in` if the model requires it.
        *   `async update(self, session: AsyncSession, *, db_obj: ModelType, obj_in: Union[UpdateSchemaType, Dict[str, Any]]) -> ModelType`:
            *   Takes existing DB object (`db_obj`) and Pydantic schema or dict for updates.
            *   Updates fields, adds to session, commits, refreshes.
            *   **Crucial**: `db_obj` should have been fetched in a guild-aware manner. This update method itself doesn't re-verify `guild_id` unless `obj_in` tries to change it (which should be disallowed or handled carefully).
        *   `async remove(self, session: AsyncSession, *, id: Any) -> Optional[ModelType]`:
            *   Gets object by `id`, deletes, commits.
            *   **Crucial**: This is a generic remove. For guild-specific data, a `remove_by_guild` is needed.
        *   `async remove_by_guild(self, session: AsyncSession, *, id: Any, guild_id: int) -> Optional[ModelType]`:
            *   Gets object by `id` AND `guild_id`, then deletes.
    *   **Implementation Details:**
        *   Use `select()` statements with `session.execute()`.
        *   For methods requiring `guild_id`, add `where(self.model.guild_id == guild_id)`.
        *   Handle potential `NoResultFound` or other SQLAlchemy exceptions gracefully, returning `None` or raising custom exceptions.
        *   Logging for all operations.

    ```python
    # src/core/crud_base.py
    import logging
    from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union
    from pydantic import BaseModel as PydanticBaseModel
    from sqlalchemy.ext.asyncio import AsyncSession
    from sqlalchemy.future import select
    from sqlalchemy import delete, update
    from core.database import Base as SQLAlchemyBase # Your SQLAlchemy Base

    ModelType = TypeVar("ModelType", bound=SQLAlchemyBase)
    CreateSchemaType = TypeVar("CreateSchemaType", bound=PydanticBaseModel)
    UpdateSchemaType = TypeVar("UpdateSchemaType", bound=PydanticBaseModel)

    logger = logging.getLogger(__name__)

    class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
        def __init__(self, model: Type[ModelType]):
            self.model = model

        async def get(self, session: AsyncSession, id: Any) -> Optional[ModelType]:
            statement = select(self.model).where(self.model.id == id)
            result = await session.execute(statement)
            return result.scalar_one_or_none()

        async def get_by_guild(self, session: AsyncSession, *, id: Any, guild_id: int) -> Optional[ModelType]:
            if not hasattr(self.model, "guild_id"):
                logger.warning(f"Model {self.model.__name__} does not have guild_id attribute for get_by_guild.")
                return await self.get(session, id) # Fallback or raise error
            statement = select(self.model).where(self.model.id == id, self.model.guild_id == guild_id)
            result = await session.execute(statement)
            return result.scalar_one_or_none()

        async def get_multi(
            self, session: AsyncSession, *, skip: int = 0, limit: int = 100
        ) -> List[ModelType]:
            statement = select(self.model).offset(skip).limit(limit)
            result = await session.execute(statement)
            return result.scalars().all()

        async def get_multi_by_guild(
            self, session: AsyncSession, *, guild_id: int, skip: int = 0, limit: int = 100
        ) -> List[ModelType]:
            if not hasattr(self.model, "guild_id"):
                logger.warning(f"Model {self.model.__name__} does not have guild_id attribute for get_multi_by_guild.")
                return await self.get_multi(session, skip=skip, limit=limit) # Fallback or raise error
            statement = select(self.model).where(self.model.guild_id == guild_id).offset(skip).limit(limit)
            result = await session.execute(statement)
            return result.scalars().all()

        async def create(self, session: AsyncSession, *, obj_in: CreateSchemaType) -> ModelType:
            obj_in_data = obj_in.model_dump()
            db_obj = self.model(**obj_in_data)
            session.add(db_obj)
            await session.flush() # Use flush to get ID before commit if needed elsewhere in transaction
            await session.refresh(db_obj)
            logger.info(f"Created {self.model.__name__} with ID {db_obj.id}")
            return db_obj

        async def update(
            self, session: AsyncSession, *, db_obj: ModelType, obj_in: Union[UpdateSchemaType, Dict[str, Any]]
        ) -> ModelType:
            obj_data = db_obj.__dict__
            if isinstance(obj_in, dict):
                update_data = obj_in
            else:
                update_data = obj_in.model_dump(exclude_unset=True)

            for field in obj_data:
                if field in update_data:
                    setattr(db_obj, field, update_data[field])

            session.add(db_obj)
            await session.flush()
            await session.refresh(db_obj)
            logger.info(f"Updated {self.model.__name__} with ID {db_obj.id}")
            return db_obj

        async def remove(self, session: AsyncSession, *, id: Any) -> Optional[ModelType]:
            obj = await self.get(session, id)
            if obj:
                await session.delete(obj)
                await session.flush()
                logger.info(f"Removed {self.model.__name__} with ID {id}")
                return obj
            return None

        async def remove_by_guild(self, session: AsyncSession, *, id: Any, guild_id: int) -> Optional[ModelType]:
            obj = await self.get_by_guild(session, id=id, guild_id=guild_id)
            if obj:
                await session.delete(obj)
                await session.flush()
                logger.info(f"Removed {self.model.__name__} with ID {id} for guild {guild_id}")
                return obj
            return None
    ```
    *   Create specific CRUD classes for each model, inheriting from `CRUDBase` (e.g., `CRUDGuildConfig(CRUDBase[GuildConfig, GuildConfigCreate, GuildConfigUpdate])`). These will be in `src/core/crud/crud_<modelname>.py`.

**3. Rule Configuration Module (`src/core/rules.py`):**
    *   **Model:** `RuleConfig` (defined in Task 0.2, has `guild_id`, `key`, `value_json`).
    *   **CRUD:** Create `src/core/crud/crud_rule_config.py` with `CRUDRuleConfig` inheriting `CRUDBase`.
        *   Add custom methods like `get_by_key_and_guild(session, key, guild_id)` and `get_all_by_guild(session, guild_id)`.
    *   **Caching Mechanism (In-memory, guild-scoped):**
        *   Use a dictionary for caching: `_rule_cache: Dict[int, Dict[str, Any]] = {}` (guild_id -> {key -> value}).
        *   Consider using `cachetools.TTLCache` or `cachetools.LRUCache` for more advanced caching strategies if the number of rules becomes very large or if TTL is needed. For now, a simple dict is fine.
    *   **`async load_rules_config_for_guild(session: AsyncSession, guild_id: int) -> Dict[str, Any]`:**
        *   Fetches all `RuleConfig` records for the `guild_id` using `CRUDRuleConfig`.
        *   Populates `_rule_cache[guild_id]` with these rules.
        *   Returns the loaded rules for the guild.
        *   Logs the loading process.
    *   **`async get_rule(session: AsyncSession, guild_id: int, key: str, default: Optional[Any] = None) -> Any`:**
        *   Checks if `guild_id` is in `_rule_cache`. If not, calls `load_rules_config_for_guild`.
        *   Retrieves the rule `value_json` from `_rule_cache[guild_id].get(key, default)`.
        *   Logs cache hit/miss and rule retrieval.
    *   **`async update_rule_config(session: AsyncSession, guild_id: int, key: str, value: Any) -> RuleConfig`:**
        *   Uses `CRUDRuleConfig` to find an existing rule by `key` and `guild_id`.
        *   If exists, updates its `value_json`.
        *   If not, creates a new `RuleConfig` entry.
        *   Refreshes `_rule_cache[guild_id]` for this key (or reloads all for simplicity initially).
        *   Logs the update.
        *   Returns the updated/created `RuleConfig` object.
    *   **Cache Invalidation:**
        *   For a single-instance bot, updating `_rule_cache` on `update_rule_config` is sufficient.
        *   For multi-instance deployments (future consideration):
            *   A proper distributed cache (like Redis) would be needed.
            *   Or, a pub/sub mechanism for cache invalidation signals between instances.
            *   For now, assume single instance or that cache staleness for a short period is acceptable.

**4. Error Handling and Logging:**
    *   Implement try-except blocks in all utility functions for database errors (e.g., `SQLAlchemyError`).
    *   Log errors with detailed context (guild_id, operation, parameters).
    *   Return meaningful values (e.g., `None`, empty list) or raise custom, more specific exceptions where appropriate.

**5. Testing Considerations:**
    *   **Unit Tests for `CRUDBase`:**
        *   Mock `AsyncSession` and model methods.
        *   Test each CRUD method for correct query construction (especially `guild_id` filtering) and interaction with the session.
    *   **Unit Tests for `CRUDRuleConfig`:**
        *   Test custom methods like `get_by_key_and_guild`.
    *   **Unit Tests for `core.rules` module:**
        *   Mock `CRUDRuleConfig` and `AsyncSession`.
        *   Test `load_rules_config_for_guild` (cache population).
        *   Test `get_rule` (cache hit, cache miss and load, default value).
        *   Test `update_rule_config` (creation of new rule, update of existing rule, cache update).
    *   **Unit Tests for `@transactional` decorator:**
        *   Test successful commit.
        *   Test rollback on exception.
        *   Test session injection/management.
Result: A set of utilities for reliable, secure (guild-isolated) DB data access and configurable rules with caching. Cache invalidation strategies considered for multi-instance deployments if applicable.


🌍 Phase 1: Game World (Static & Generated)
🌍 Task 1.1: Location Model (i18n, Guild-Scoped) (A-Z Implementation Plan)

**Overall Context Reminder**: This model is part of a scalable backend for a Discord bot supporting independent RPG worlds per guild. Locations are fundamental to the game world, which is procedurally generated by AI and managed by game mechanics. Data must be guild-isolated and support multilingual content.

**1. Model Definition (`src/models/location.py`):**
    *   Ensure the `Location` SQLAlchemy model is fully defined, inheriting from `BaseModel` (or `Base`) and `TimestampMixin` (as established in Task 0.2).
    *   **Fields**:
        *   `id: Mapped[int]` (PK, from `BaseModel`).
        *   `guild_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("guild_configs.id"), index=True, nullable=False)` (Ensures guild isolation).
        *   `parent_location_id: Mapped[Optional[int]] = mapped_column(Integer, ForeignKey("locations.id"), nullable=True, index=True)` (For hierarchical locations, e.g., a room within a building).
        *   `static_id: Mapped[Optional[str]] = mapped_column(String(255), index=True, nullable=True)` (Unique identifier within the guild for pre-defined or key locations. Should have a `UniqueConstraint` with `guild_id`).
        *   `name_i18n: Mapped[Dict[str, str]] = mapped_column(JSONB, nullable=False)` (Localized names, e.g., `{"en": "Forest Path", "ru": "Лесная Тропа"}`).
        *   `description_i18n: Mapped[Dict[str, str]] = mapped_column(JSONB, nullable=False)` (Localized descriptions).
        *   `location_type: Mapped[Optional[str]] = mapped_column(String(50), index=True, nullable=True)` (e.g., "forest", "city_street", "dungeon_room", "shop". Consider an Enum later if types become fixed, but string allows flexibility for AI generation initially).
        *   `coordinates_json: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)` (e.g., `{"x": 10, "y": 20, "z": 0, "map_id": "world_map"}`. Structure can be flexible).
        *   `neighbor_locations_json: Mapped[Optional[List[Dict[str, Any]]]] = mapped_column(JSONB, nullable=True)`
            *   Structure for each element in list: `{"target_location_id": int, "connection_type_i18n": {"en": "winding path", "ru": "извилистая тропа"}, "travel_time_minutes": Optional[int], "conditions_json": Optional[Dict], "is_one_way": Optional[bool]}`.
            *   `conditions_json` could hold requirements like `{"requires_item_static_id": "rope", "requires_skill_check": {"skill": "climbing", "dc": 15}}`.
        *   `generated_details_json: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)` (For AI-generated content like interactive elements, points of interest, ambient details, e.g., `{"interactive_elements": [{"id": "lever1", "name_i18n": ..., "description_i18n": ..., "actions": ["pull"]}]}`).
        *   `ai_metadata_json: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)` (Metadata related to AI generation, e.g., prompt used, generation version, theme keywords).
        *   `properties_json: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)` (For other dynamic properties, e.g., `{"has_light_source": true, "encounter_rate_modifier": -0.1}`).
    *   **Relationships**:
        *   `guild_config: Mapped["GuildConfig"] = relationship(back_populates="locations")` (Assuming `GuildConfig` has `locations: Mapped[List["Location"]] = relationship(back_populates="guild_config")`).
        *   `parent_location: Mapped[Optional["Location"]] = relationship(back_populates="child_locations", remote_side=[id])`
        *   `child_locations: Mapped[List["Location"]] = relationship(back_populates="parent_location")`
    *   **Table Args**:
        *   `UniqueConstraint('guild_id', 'static_id', name='uq_location_guild_static_id')` (if `static_id` is not globally unique but per guild). If `static_id` needs to be globally unique for some reason, this constraint changes. The task implies uniqueness *within the guild*.

**2. Alembic Migration:**
    *   After defining/updating the `Location` model and ensuring it's imported in `src/models/__init__.py`:
    *   Generate a new migration: `alembic revision -m "add_location_model_and_relations"`
    *   Review and edit the generated migration script:
        *   Ensure `op.create_table('locations', ...)` includes all specified columns with correct types (e.g., `postgresql.JSONB` for JSON fields), constraints (PK, FKs, Unique).
        *   Ensure indexes are created for `guild_id`, `parent_location_id`, `static_id`, and `location_type`.
    *   Apply the migration: `alembic upgrade head`.

**3. CRUD Operations (`src/core/crud/crud_location.py`):**
    *   Create `CRUDLocation(CRUDBase[Location, LocationCreateSchema, LocationUpdateSchema])`.
        *   (Pydantic schemas `LocationCreateSchema`, `LocationUpdateSchema` will need to be defined in `src/schemas/location.py`, mirroring the model fields intended for creation/update).
    *   Implement specific query methods if needed beyond `CRUDBase`:
        *   `async get_by_static_id(self, session: AsyncSession, *, guild_id: int, static_id: str) -> Optional[Location]:`
            *   Query: `select(Location).where(Location.guild_id == guild_id, Location.static_id == static_id)`
        *   `async get_children_of_location(self, session: AsyncSession, *, location_id: int, guild_id: int) -> List[Location]:`
            *   Query: `select(Location).where(Location.guild_id == guild_id, Location.parent_location_id == location_id)`
        *   `async get_locations_by_type(self, session: AsyncSession, *, guild_id: int, location_type: str) -> List[Location]:`
            *   Query: `select(Location).where(Location.guild_id == guild_id, Location.location_type == location_type)`

**4. Utility Functions (`src/core/locations_utils.py`):**
    *   **`async get_location(session: AsyncSession, guild_id: int, location_id: int) -> Optional[Location]:`**
        *   Uses `crud_location.get_by_guild(session, id=location_id, guild_id=guild_id)`.
    *   **`async get_location_by_static_id(session: AsyncSession, guild_id: int, static_id: str) -> Optional[Location]:`**
        *   Uses `crud_location.get_by_static_id(session, guild_id=guild_id, static_id=static_id)`.
    *   **`get_localized_text(entity_with_i18n_fields: Any, field_name: str, language: str, fallback_lang: str = "en") -> str:`**
        *   This function is generic and likely already exists or will be part of a broader localization utility module.
        *   Retrieves text from a JSONB field (e.g., `name_i18n`).
        *   Logic:
            1. Access `json_field = getattr(entity_with_i18n_fields, field_name)`.
            2. If `json_field` is a dict:
                *   Try `json_field.get(language)`.
                *   If not found, try `json_field.get(fallback_lang)`.
                *   If still not found, return a placeholder like `f"{field_name}_undefined"` or the first available value.
            3. Else, return a placeholder.
        *   Ensure robust error handling (e.g., field doesn't exist, not a dict).

**5. Initial Data Population (Conceptual - `on_guild_join`):**
    *   The task mentions: "Populate the DB with initial static world lore and locations (if any) during on_guild_join (0.1), linked to the guild."
    *   This implies that in `src/bot/events.py` (or wherever `on_guild_join_handler` is), after `GuildConfig` is created, there might be a call to a function like `async def populate_initial_guild_locations(session: AsyncSession, guild_id: int):`.
    *   `populate_initial_guild_locations` would:
        *   Read from a predefined data source (e.g., a JSON file, or hardcoded dicts) containing definitions for default/static locations.
        *   For each static location definition:
            *   Create a `LocationCreateSchema` Pydantic model.
            *   Call `crud_location.create(session=session, obj_in=location_data_schema)`.
        *   This ensures static locations are created with their `guild_id`.

**6. Testing Considerations:**
    *   **Unit Tests for `Location` model (`tests/models/test_location.py`):**
        *   Test instance creation with all fields.
        *   Test i18n field handling (setting/getting).
        *   Test JSON field handling.
        *   Test relationships (parent/child) if mock data allows.
    *   **Unit Tests for `CRUDLocation` (`tests/core/crud/test_crud_location.py`):**
        *   Test `get_by_static_id`.
        *   Test `get_children_of_location`.
        *   Test `get_locations_by_type`.
        *   Ensure `guild_id` filtering is correctly applied in all relevant base and custom methods.
    *   **Unit Tests for `locations_utils.py` (`tests/core/test_locations_utils.py`):**
        *   Test `get_location` and `get_location_by_static_id` (mocking CRUD).
        *   Thoroughly test `get_localized_text` with various scenarios: language found, fallback language used, no language found, field not i18n, field missing.
    *   **Integration Tests (Conceptual for `on_guild_join`):**
        *   Test the `on_guild_join` event flow to ensure `populate_initial_guild_locations` is called and successfully creates locations in a test DB.
Result: Location model defined, static data accessible and isolated, localization utilities available.


🌍 1.2 Player and Party System (ORM, Commands, Guild-Scoped). (0.2, 0.3, 0.1)
Description: **A to Z Implementation**: Fully implement player and party management within a guild, adhering to `RuleConfig` for all relevant behaviors.
    - **Models**: Ensure `Player` and `Party` models (Task 0.2, 2.1) are complete, including all stats, statuses (PlayerStatus, PartyTurnStatus ENUMs), inventory links, quest progress links, and `guild_id`.
    - **Player Creation (`/start` command)**:
        - On `/start`, correctly identify `guild_id`. Create `Player` record.
        - Assign starting location, language, stats (HP, attributes), XP, level, gold based on `RuleConfig` (e.g., `player:starting_stats`, `player:starting_location_static_id`).
        - Set initial status (e.g., `PlayerStatus.EXPLORING`).
        - Provide comprehensive, localized feedback. Handle cases where player already exists.
    - **Party Management Commands (`/party create <name>`, `/party join <name>`, `/party leave`, `/party disband`, `/party invite <player>`, `/party kick <player>`, `/party promote <player>`)**:
        - All commands operate strictly within `guild_id`.
        - **Create**: Adhere to `RuleConfig` for party size limits, naming conventions. Auto-assign leader.
        - **Join**: Adhere to `RuleConfig` (open/invite-only, level requirements). Handle player already in party, party full. Update player/party locations consistently.
        - **Leave**: Handle leader leaving (transfer leadership per `RuleConfig` or disband). Update player/party locations.
        - **Disband**: Only by leader or per `RuleConfig`. Notify members.
        - **Invite/Kick/Promote**: Permission checks (leader or `RuleConfig` based roles).
        - All operations must update `Player.current_party_id` and `Party.player_ids_json` atomically.
        - Update `Party.turn_status` and `Player.current_status` appropriately (e.g., if joining an active party).
        - Log all party changes (PartyLog or StoryLog). Provide localized feedback for all success/failure scenarios.
    - **Utilities**: Ensure robust `get_player`, `get_party`, `get_players_in_location`, `get_party_members` utilities, all guild-scoped.
    - **Error Handling**: Graceful handling of non-existent players/parties, permission issues, invalid states.
Result: A comprehensive and rule-driven player and party management system with full command support, logging, and i18n feedback.


🌍 1.3 Movement Logic (Player/Party, Guild-Scoped). (Tasks 4, 5, 0.3, 14, 25)
Description: **A to Z Implementation**: Fully implement player and party movement between locations within a guild, respecting all game rules and side effects.
    - **API**: `handle_move_action(guild_id: int, player_id: int, target_location_identifier: str)` (called by Action Processor).
    - **Target Resolution**: Robustly resolve `target_location_identifier` (name, static_id, alias) to a `Location` ID within the guild, considering player's language.
    - **Connection Check**: Verify valid connection (static or generated `neighbor_locations_json`) between current and target locations. Check for one-way connections, conditional connections (e.g., requires item, quest status - from `Location.properties_json` or `RuleConfig`).
    - **Movement Permissions**:
        - Check player status (e.g., not in combat, not busy).
        - **Party Movement**:
            - If player is in a party, apply `RuleConfig` for party movement (e.g., `rules:party:movement:policy` = "leader_only", "all_members_ready", "any_member").
            - If "all_members_ready", check status of all party members.
            - If party moves, all members' locations are updated.
    - **Costs & Checks**: Apply movement costs (time, resources like food/stamina from `Player.stats` or `RuleConfig`) if defined. Perform skill checks (e.g., survival for difficult terrain) if required by location connection properties or `RuleConfig`, using Check Resolver (Task 6.3.2). Movement fails if checks fail critically or costs can't be met.
    - **Transactional Update**: Player/Party location updates, resource deductions, and movement event logging must occur within a single atomic transaction for the guild.
    - **Event Logging**: Log `EventType.MOVEMENT` to `StoryLog` with details (player/party, old/new location, path taken, duration).
    - **Post-Movement Hook**: After successful commit, asynchronously call `on_enter_location(guild_id, entity_id, entity_type, new_location_id, old_location_id)` (Task related to 14/World Events). This hook can trigger location descriptions, new encounters, AI generation, quest updates.
    - **Feedback**: Provide comprehensive, localized feedback to the player(s) for success, failure (no path, locked, failed check, insufficient resources), and any significant events during movement.
    - **Error Handling**: Handle invalid inputs, non-existent locations, system errors gracefully.
Result: A robust, rule-driven movement system supporting individual and party travel, with integrated checks, costs, event logging, and hooks for dynamic content.


🧠 Phase 2: AI Integration - Generation Core
🧠 2.1 Finalize Definition of ALL DB Schemas (i18n, Guild ID). (0.2, 0.3)
Description: Final structure for all ORM schemas (fields and relationships) for all game entities. Every model storing game state must have a `guild_id` field. Text fields - JSONB (`_i18n`).
Including models: `GeneratedLocation` (extends Location 4.1?), `GeneratedNpc`, `GeneratedFaction`, `GeneratedQuest`, `QuestStep`, `Questline`, `Item`, `InventoryItem`, `StoryLog`, `Relationship`, `PlayerNpcMemory`, `PartyNpcMemory`, `Ability`, `Skill`, `StatusEffectDefinition`, `ActiveStatusEffect`, `ItemProperty` (if separate from Item.properties_json), `MobileGroup`, `GlobalEvent`, `CraftingRecipe`, `PendingGeneration`, `PendingConflict`, `CombatEncounter`. All these models MUST INCLUDE `guild_id` (BIGINT, Indexed) as part of the primary key or a unique index, and as a Foreign Key to `GuildConfig` (0.2). Ensure all relationships, constraints, and indexing are optimal.
Result: All database models are fully defined, supporting guild isolation, i18n, and all planned game mechanics. Migrations are up-to-date.


🧠 2.2 AI Prompt Preparation Module. (1, 4, 7, 13, 14, 30, 36, 37, 38, 39, 40)
Description: **A to Z Implementation**: Develop a comprehensive and highly configurable module for preparing detailed prompts for the AI (LLM) to generate diverse game content (locations, NPCs, items, quests, factions, relationships, events, narrative text).
    - **API**: `prepare_ai_prompt(session, guild_id: int, generation_type: str, context: Dict[str, Any]) -> str`.
        - `generation_type`: e.g., "location_description", "npc_dialogue", "quest_full", "item_magical", "faction_creation", "event_dynamic".
        - `context`: Contains specific details relevant to the `generation_type` (e.g., `location_id`, `player_id`, `npc_id`, `theme_keywords`, `difficulty_level`, `previous_events_summary`).
    - **Context Aggregation**:
        - Dynamically collect comprehensive context from the database based on `guild_id`, `generation_type`, and `context` dict. This includes:
            - Current `Location` data (description, type, neighbors, existing entities).
            - `Player`/`Party` data (level, class, current quests, recent actions, relationships).
            - `GeneratedNpc` data (personality, faction, existing memory, relationships).
            - `GeneratedFaction` data (ideology, members, relationships).
            - Active `GeneratedQuest` states.
            - Relevant `WorldState` entries (global flags, lore snippets from `RuleConfig` key `world_lore:*`).
            - Relevant `RuleConfig` entries that dictate generation constraints or style (e.g., `ai:generation:npc:personality_archetypes`, `ai:generation:quest:common_themes:<location_type>`).
    - **Game Term Dictionary**: Include a "dictionary" of game terms (entity names, stats, skills, abilities, status effects, item properties) specific to the guild, extracted from `RuleConfig` and relevant DB models, to guide AI consistency.
    - **Prompt Structuring**:
        - Use structured prompt engineering techniques. Define clear sections in the prompt: Role (e.g., "You are a master storyteller..."), Task (e.g., "Generate a detailed NPC..."), Context (all aggregated data), Constraints (from `RuleConfig`), Output Format (JSON schema for structured data, or style guide for narrative).
        - Ensure prompts request i18n text generation (e.g., for `name_i18n`, `description_i18n` fields) in the guild's main language and English (or other configured languages via `GuildConfig.supported_languages_json`).
    - **Dynamic Content Requests**: Support requesting generation of specific sub-components (e.g., just NPC dialogue lines, just quest objectives) based on `generation_type` and `context`.
    - **Error Handling**: Gracefully handle missing context data or rules, logging issues.
    - **Configurability**: The content and structure of prompts should be influenced by `RuleConfig` (e.g., `ai:prompts:<generation_type>:template`, `ai:prompts:global_instructions`).
Result: A robust and flexible AI prompt preparation module capable of generating highly contextualized and tailored prompts for a wide variety of content generation tasks, fully respecting guild-specific data and rules, and i18n requirements.


🧠 2.3 AI Response Parsing and Validation Module. (7, 13, 14, 30, 37, 39, 18, 16)
Description: **A to Z Implementation**: Develop a comprehensive module for parsing, validating, and (where feasible) auto-correcting AI-generated content.
    - **API**: `parse_and_validate_ai_response(raw_ai_output_text: str, guild_id: int, expected_schema_type: str) -> Union[ParsedAiData, CustomValidationError]`.
        - `expected_schema_type`: Hints at the primary Pydantic model to use for parsing (e.g., "NpcData", "QuestData").
    - **Parsing**:
        - Robustly parse JSON from `raw_ai_output_text`. Handle malformed JSON and common AI formatting quirks (e.g., markdown code blocks).
        - Use Pydantic models (defined in `ai_response_parser.py` like `ParsedNpcData`, `ParsedItemData`, etc., grouped under `ParsedAiData`) for structural validation of all expected entity types.
    - **Multi-Level Validation**:
        - **Schema Validation**: Ensure the parsed data conforms to the expected Pydantic model structure for the `expected_schema_type`.
        - **Semantic Validation (Rule-Based)**:
            - Cross-reference generated data against `RuleConfig` for the `guild_id`. Examples:
                - NPC stats within defined ranges for their level/type (`rules:npc:stats:<type>`).
                - Item prices/properties consistent with economic rules (`rules:economy:item_balance`).
                - Quest structures adhering to defined templates or constraints (`rules:quest:structure:<type>`).
                - Faction relationships consistent with lore or defined conflicts (`rules:faction:relationship_constraints`).
                - Generated text (names, descriptions) checked for profanity or forbidden terms (`rules:text_filter:global`).
            - Check for consistency within the generated batch (e.g., unique `static_id`s if multiple entities are generated).
            - Verify i18n requirements: ensure text fields are provided in all languages specified in `GuildConfig.supported_languages_json`.
        - **Contextual Validation**: Check generated content against existing game state if context was provided during prompt generation (e.g., generated NPC faction should exist, quest giver NPC should exist).
    - **Error Reporting**: If validation fails, return a structured `CustomValidationError` object containing:
        - Original problematic data snippet.
        - Specific error messages (Pydantic errors, custom semantic errors).
        - Suggested fixes or reasons for failure.
    - **Auto-Correction (Optional, Limited)**: Implement simple auto-correction for common, safe-to-fix issues (e.g., trimming whitespace, fixing minor case errors in known enum values, ensuring required i18n keys exist even if empty). More complex corrections should be flagged for Master review.
    - **Logging**: Detailed logging of parsing process, validation successes, and failures.
Result: A robust AI response processing module that ensures generated content is well-structured, conforms to guild-specific rules and game consistency, and provides clear error reporting for moderation.


🧠 2.6 AI Generation, Moderation, and Saving Logic. (7, 14, 15, 16, 17, 19, 41, OpenAI API, 0.3, 1, 3, 12, 13, 21)
Description: **A to Z Implementation**: Implement the complete end-to-end cycle for AI content generation, including triggering, processing, Master moderation, and saving to the database, ensuring data integrity and adherence to guild rules.
    - **Triggering Generation**:
        - API function `trigger_ai_generation_flow(session, bot, guild_id, generation_type: str, context: Dict[str, Any], player_id: Optional[int])`.
        - Calls `prepare_ai_prompt` (Task 2.2) to get the prompt.
        - Calls the actual LLM API (e.g., OpenAI, with appropriate error handling for API calls, rate limits, etc.). Fallback to mock if real AI fails or is disabled by `RuleConfig`.
        - Calls `parse_and_validate_ai_response` (Task 2.3).
    - **Pending Moderation**:
        - If parsing/validation is successful (or has non-critical issues), create a `PendingGeneration` record in the DB. Store: `guild_id`, trigger context, full prompt, raw AI response, parsed/validated data (as JSON), validation issues (if any), and initial status (`PENDING_MODERATION` or `VALIDATION_FAILED`).
        - If a `player_id` triggered the generation (e.g., for a dynamic event), update `Player.current_status` to `AWAITING_MODERATION`.
        - Notify the Game Master via Discord (using `GuildConfig.notification_channel_id`) about the new content awaiting review, including `PendingGeneration.id`.
    - **Master Moderation API (Discord Commands - part of Task 15.1)**:
        - `/master_ai review [status_filter] [page]`: List `PendingGeneration` records for the guild.
        - `/master_ai view <pending_id>`: Display full details of a `PendingGeneration` record (prompt, raw response, parsed data, validation issues).
        - `/master_ai edit <pending_id> <field_to_edit> <new_value_json>`: Allow Master to edit `parsed_validated_data_json` or `master_notes`. Sets status to `EDITED_PENDING_APPROVAL`.
        - `/master_ai approve <pending_id>`: Set status to `APPROVED`.
        - `/master_ai reject <pending_id> [reason]`: Set status to `REJECTED`, store reason.
    - **Saving Worker/Logic (`save_approved_generation`)**:
        - API `save_approved_generation(session, pending_generation_id, guild_id)`.
        - Triggered after Master approves (or auto-approved by `RuleConfig` if `ai:moderation:auto_approve_on_validation_success` is true).
        - Retrieve the `PendingGeneration` record.
        - **Atomically save all generated entities** from `parsed_validated_data_json` to their respective database tables within a single transaction for the guild.
            - Correctly map parsed data (e.g., `ParsedNpcData`, `ParsedQuestData`) to SQLAlchemy models.
            - Handle creation of related entities (e.g., `QuestStep` for `GeneratedQuest`, `InventoryItem` for `GeneratedNpc` traders from `ParsedNpcTraderData.generated_inventory_items`).
            - Ensure `guild_id` is correctly propagated to all saved entities.
            - Resolve internal references (e.g., a generated NPC being a quest giver for a generated quest in the same batch) using `static_id`s and a two-pass saving process if needed.
        - If saving is successful, update `PendingGeneration.status` to `SAVED`.
        - If saving fails, update status to `ERROR_ON_SAVE` and log detailed errors.
    - **Post-Save Actions**:
        - If player status was `AWAITING_MODERATION`, revert it (e.g., to `EXPLORING`), considering if other pending generations for the player still exist.
        - Asynchronously call relevant game event hooks (e.g., `on_enter_location` if new location content was generated, `on_new_entities_created`).
    - **Error Handling & Logging**: Comprehensive error handling and logging throughout the entire pipeline.
Result: A fully operational, fault-tolerant AI content generation pipeline from triggering to saving, with robust moderation tools, ensuring all generated content is validated, approved, and correctly integrated into the game world per guild.


🎲 Phase 6: Action Resolution Systems (Core Mechanics)
🎲 6.3.1 Dice Roller Module. (None)
Description: Implement a flexible dice string parser (e.g., "2d6+3", "1d20-1", "best3of4d6") and rolling function. This module is guild-agnostic.
API: `roll_dice(dice_string: str) -> Tuple[int, List[int], str]` where the tuple contains (total_result, list_of_individual_rolls, normalized_dice_string_used).
Handles various dice types, counts, modifiers, and common mechanics like drop lowest/highest.
Result: A reliable dice rolling utility usable by any game system requiring random number generation based on standard dice notation.


🎲 6.3.2 Check Resolver Module. (14, 0.3, 11, 47)
Description: **A to Z Implementation**: Develop a comprehensive module for resolving attribute/skill checks based on configurable `RuleConfig` rules, entity stats, and situational context.
    - **API**: `resolve_check(session, guild_id: int, check_type: str, entity_doing_check_id: int, entity_doing_type: RelationshipEntityType, target_entity_id: Optional[int] = None, target_entity_type: Optional[RelationshipEntityType] = None, difficulty_dc: Optional[int] = None, opposed_check_by_target: bool = False, base_attribute: Optional[str] = None, skills_involved: Optional[List[str]] = None, check_context: Optional[Dict[str, Any]] = None) -> CheckResult`.
    - **Rule Loading**: Load check-specific rules from `RuleConfig` using `guild_id` and `check_type` (e.g., `checks:<check_type>:base_dc`, `checks:<check_type>:relevant_attributes`, `checks:<check_type>:situational_modifiers_formula`).
    - **Entity Data**: Load `entity_doing_check` (and `target_entity` if applicable) to access their base stats, skills, current status effects, equipped items, and relationships.
    - **Effective Stats Calculation**: Calculate effective stats/skills for the check, considering temporary effects from statuses, item bonuses (from `properties_json`), and ability modifiers.
    - **Modifier Calculation**:
        - Calculate base modifier from attributes (e.g., `(attribute_value - 10) // 2`) and skill ranks.
        - Apply situational modifiers based on `check_context` and `RuleConfig` formulas (e.g., advantage/disadvantage, numerical bonuses/penalties from weather, terrain, lighting, social situations).
        - Apply modifiers from active status effects on the `entity_doing_check`.
        - Apply modifiers derived from relationships between `entity_doing_check` and `target_entity` (Task 37).
    - **Dice Rolling**: Call Dice Roller (Task 6.3.1) using dice notation from `RuleConfig` (e.g., "1d20", "2d6").
    - **Result Determination**:
        - If `opposed_check_by_target` is true, recursively call `resolve_check` for the target, and compare results.
        - Otherwise, compare total roll + modifiers against `difficulty_dc` (either provided, from `RuleConfig`, or derived from target's opposing stats/skills).
        - Determine outcome (e.g., critical success, success, failure, critical failure) based on `RuleConfig` (e.g., degrees of success/failure, crit ranges).
    - **`CheckResult` Object**: Return a comprehensive `CheckResult` Pydantic model containing: input parameters, all calculated modifiers (with sources), dice roll details, final result, outcome, and any narrative snippets for feedback.
    - **Error Handling**: Gracefully handle missing rules, invalid entity IDs, or calculation errors.
    - **Logging**: Detailed logging of the check resolution process for auditing and debugging.
Result: A robust and highly configurable check resolution system capable of handling diverse game situations, modifiers, and outcomes, providing detailed results for game logic and player feedback.


⚙️ 6.10 Action Parsing and Recognition Module (NLU & Intent/Entity). (1, 4, 7, 14, 0.2, 0.3, Choose NLU Libs, Guild-Scoped Dictionary)
Description: **A to Z Implementation**: Develop a sophisticated Natural Language Understanding (NLU) module to parse player narrative input, identify intents, and extract relevant entities within the context of their specific guild.
    - **API**: `parse_player_input(raw_text: str, guild_id: int, player_id: int, current_game_context: Dict[str, Any]) -> ParsedAction`.
        - `current_game_context`: Includes player's location, nearby entities, active quests, dialogue state, etc., to aid disambiguation.
    - **NLU Library Integration**: Choose and integrate a suitable NLU library (e.g., Rasa, spaCy with custom components, or a cloud-based NLU service if external calls are permitted). Configure it for high accuracy.
    - **Intent Recognition**:
        - Define and train/configure the NLU model to recognize a comprehensive set of game intents (e.g., "move", "attack", "talk", "use_item", "examine", "trade_buy", "cast_ability", "party_invite", "quest_accept").
        - Handle ambiguous inputs and provide clarification prompts or default actions where appropriate (based on `RuleConfig`).
    - **Entity Extraction**:
        - Extract all relevant game entities from the text: target names (NPCs, players, items), locations, directions, quantities, ability names, etc.
        - **Guild-Scoped Entity Dictionary**: Dynamically build and use an entity dictionary for the NLU model based on the current `guild_id`. This dictionary includes names of known locations, NPCs, items, abilities, quests, factions, etc., within that guild to improve recognition accuracy. This dictionary should be updatable as new entities are discovered or generated.
        - Normalize extracted entities (e.g., map synonyms to canonical names).
    - **Coreference Resolution**: Resolve pronouns and ambiguous references (e.g., "talk to him", "use it") based on `current_game_context` and dialogue history.
    - **Action Storage**: Store the recognized `ParsedAction` (containing intent, entities, confidence scores, raw text) in `Player.collected_actions_json` for processing by the Turn Processor (Task 6.11). If player is in `PlayerStatus.DIALOGUE`, route directly to Dialogue System (Task 53).
    - **Multi-language Support**: Ensure NLU model can process input in all supported languages for the guild (defined in `GuildConfig.supported_languages_json`).
    - **Error Handling & Fallbacks**: If NLU fails to understand the input with sufficient confidence, provide appropriate feedback to the player (e.g., "I didn't understand that, try phrasing differently.") or trigger a fallback mechanism.
    - **Logging**: Log raw input, NLU processing steps, recognized intent, and extracted entities for analysis and model improvement.
Result: A powerful NLU module that accurately interprets diverse player inputs in multiple languages, leveraging guild-specific context to provide structured actions for the game engine.


⚙️ 6.12 Turn Queue System (Turn Controller) - Per-Guild Processing. (1, 2, 13, 21, 1.3, 19, 11.3, 25, 35, 15, 36, Per-Guild Async Workers/Queue Management)
Description: **A to Z Implementation**: Develop a robust Turn Controller to manage the step-by-step progression of game time and action resolution independently for each active guild.
    - **State Management**: Reliably track `PlayerStatus` (e.g., `IDLE`, `AWAITING_TURN_SUBMISSION`, `TURN_ENDED_PENDING_RESOLUTION`, `PROCESSING_GUILD_TURN`, `IN_COMBAT`, `IN_DIALOGUE`, `AWAITING_MODERATION`) and `PartyTurnStatus` for all players and parties.
    - **Turn Submission**:
        - Handle `/end_turn` (for individual players not in a party or when party rules allow individual turns) and `/end_party_turn` commands.
        - Atomically update player/party status to `TURN_ENDED_PENDING_RESOLUTION` upon valid turn submission.
    - **Guild Turn Readiness Check (`process_guild_turn_if_ready`)**:
        - This function, likely called periodically or after every turn submission for a guild:
            - Checks if all active players/parties (those not `IDLE`, `IN_DIALOGUE`, `AWAITING_MODERATION`, or already `PROCESSING_GUILD_TURN`) in a guild have submitted their turns (status `TURN_ENDED_PENDING_RESOLUTION`).
            - `RuleConfig` may define exceptions (e.g., a timer forces turn progression even if some players haven't acted: `rules:turn_controller:max_turn_wait_seconds`).
            - Consider players/parties currently `IN_COMBAT` – their actions are typically resolved immediately by the Combat Cycle (Task 5.4) rather than queued here, but their overall turn might still be part of this system.
    - **Action Processing Trigger**:
        - If a guild's turn is ready to be processed:
            - Atomically set status of all involved players/parties to `PROCESSING_GUILD_TURN`.
            - Collect all entities whose actions need processing.
            - Asynchronously initiate the Central Collected Actions Processing Module (Task 6.11) for that `guild_id`, passing the list of entities. This should be non-blocking using `asyncio.create_task` or a similar mechanism.
            - Implement a locking mechanism (`_guild_turn_processing_locks`) to prevent concurrent turn processing for the same guild.
    - **Global Event Ticks**: Integrate with a global game clock (if implemented) to trigger periodic events or NPC actions that occur outside of player turns (related to Task 14.2 Global Entity Management).
    - **Error Handling**: Robustly handle errors during status updates or when triggering action processing. Ensure locks are released.
    - **Scalability**: Design to handle numerous concurrent guilds efficiently.
    - **Logging**: Detailed logs of turn submissions, readiness checks, and initiation of action processing.
Result: A reliable and scalable Turn Controller that accurately manages game flow for multiple guilds, ensuring timely processing of player and party actions based on defined statuses and rules.


⚙️ 6.11 Central Collected Actions Processing Module (Turn Processor) - Guild-Scoped Execution. (14, 13, 14, 0.3, 19, 47, 21, 36, 38, 40, 1.3, 25, 15, 35, Conflict Resolution, Master Notification 41, Transactions 0.3)
Description: **A to Z Implementation**: The core asynchronous worker that executes all queued game logic for a single turn within a specific guild. This module must be robust, transactional, and fully integrated with all other game systems and `RuleConfig`.
    - **Worker Signature**: `process_actions_for_guild(guild_id: int, entities_and_types_to_process: List[Dict[str, Any]])`.
    - **Pre-computation/Loading**:
        - Within a transaction, load all `Player.collected_actions_json` for the specified entities. Clear these fields in the DB after loading.
        - Pre-load any frequently accessed guild-wide data or rules if beneficial.
    - **Conflict Analysis & Resolution (Pre-Execution)**:
        - **Identify Conflicts**: Analyze all loaded actions for potential conflicts based on `RuleConfig` (`rules:conflict_resolution:policies`). Conflicts can arise from:
            - Multiple players/parties targeting the same exclusive resource/NPC.
            - Contradictory party member actions (if party submitted a single "party action" composed of member intents).
            - Actions that are mutually exclusive by game rules.
        - **Automatic Resolution**: If `RuleConfig` allows automatic resolution (e.g., `highest_skill_succeeds`, `random_choice`, `leader_decides_for_party`), apply it. This may involve calling Check Resolver (Task 6.3.2). Log the resolution.
        - **Manual Moderation**: If rules require Master intervention:
            - Create `PendingConflict` record(s) with `guild_id`, details of conflicting actions, and involved entities.
            - Notify Master via Discord (Task related to 15.1).
            - Mark involved player actions as 'pending_conflict_resolution'. Processing for these players/actions pauses until Master resolves via `/master_conflict resolve`.
            - The worker may need to periodically re-check for resolved conflicts or be signaled.
    - **Action Execution Phase**:
        - Iterate through non-conflicted (or resolved) `ParsedAction` objects.
        - **For each action**:
            - Start an **atomic transaction** (using `@transactional` on handler or explicit `session.begin()`).
            - **Dispatch**: Call the appropriate handler module based on `action.intent` (e.g., Movement (1.3), Combat (5.2/5.4), Intra-Location Interaction (6.1.1), Inventory (related to 10.1/10.3), Quest event (9.3), Dialogue (11.2), Ability (3.3), Trade (10.3)).
            - Pass `guild_id`, `session`, `player_id`, and `action_data` to the handler.
            - The handler executes all game logic, performs checks, updates DB state (within the action's transaction), and returns a result object (including success/failure, feedback messages/keys, data for logging).
            - If the handler raises an exception, the transaction for that action must roll back, the error logged, and appropriate feedback prepared. Other actions in the turn should still attempt to process.
    - **Post-Execution**:
        - **Aggregate Feedback**: Collect all feedback messages/data from individual action results.
        - **Event Logging**: Ensure all significant outcomes are logged to `StoryLog` (Task 7.1) by the handlers or this module.
        - **Report Generation**: Generate a turn report for each affected player and potentially a summary for the Game Master using the Report Formatting system (Task 7.3/54). Send reports via Discord.
        - **Status Updates**: After all actions are attempted, update `Player.current_status` and `Party.turn_status` (e.g., to `IDLE` or `AWAITING_TURN_SUBMISSION` for the next turn).
    - **Error Handling**: Comprehensive error handling for database issues, unexpected exceptions from handlers, etc. Ensure guild processing doesn't get stuck.
Result: A robust, transactional, and fully rule-driven turn processing engine that correctly executes all player actions, manages conflicts, updates game state across all systems, and provides comprehensive feedback and logging for each guild.


⚙️ 6.1.1 Intra-Location Interaction Handler Module. (15, 4.1, 0.3, 15, 12, 21, 35, Rules 13/41)
Description: **A to Z Implementation**: Handles all player actions directed at objects, features, or sub-locations *within* their current main `Location`. This module must be highly configurable via `RuleConfig`.
    - **API**: `handle_intra_location_action(session, guild_id: int, player_id: int, action_data: ParsedAction) -> InteractionResult` (called by Action Processor).
    - **Interaction Types**: Robustly determine interaction type based on `action_data.intent` (e.g., "examine_object", "use_object_on_self", "use_object_on_target", "take_item_from_world", "move_to_sublocation", "manipulate_lever").
    - **Target Resolution**:
        - Identify the target entity (object, feature, sub-location name) from `action_data.entities`.
        - Load the target from `Location.generated_details_json.interactive_elements` or a dedicated `WorldObject` table if such exists, scoped to `guild_id` and current `Location.id`.
        - Handle ambiguous targets or targets not found.
    - **Rule-Driven Interactions**:
        - For the identified target and interaction type, load interaction rules from `RuleConfig` (e.g., `interactions:<object_static_id>:<intent_verb>`, or `interactions:default_object:<intent_verb>`).
        - Rules define:
            - If a skill/attribute check is required (details for Check Resolver: `check_type`, `base_dc`, `relevant_attribute/skill`).
            - Prerequisite conditions (e.g., player status, required items in inventory, quest state, world flags).
            - Consequences of success/failure/critical outcomes:
                - `WorldState` changes (setting flags via `RuleConfig` update).
                - Item acquisition/loss (update `Player.inventory_items`).
                - Quest triggers or updates (call Quest System Task 9.3).
                - Relationship changes (call Relationship System Task 8.4).
                - Unlocking new interactions or revealing information (update object's state in `Location.generated_details_json` or `WorldObject` table).
                - Applying status effects to player/target.
                - Narrative feedback text keys for localization.
    - **Check Resolution**: If a check is required, call Check Resolver (Task 6.3.2) with all necessary context.
    - **State Updates**: All DB changes (player inventory, object state, WorldState via `RuleConfig`) must occur within the action's transaction. Update `Player.current_sublocation_name` if moving to a sub-location.
    - **Event Logging**: Log interaction events to `StoryLog` (Task 7.1) with details: player, target, action, check result (if any), and key consequences.
    - **Feedback**: Return a structured `InteractionResult` with localized feedback messages (via Report Formatter Task 7.3/54) describing the outcome.
    - **Error Handling**: Handle invalid targets, missing rules, failed checks, and other exceptional conditions gracefully.
Result: A highly flexible and rule-driven system for managing detailed interactions within locations, enabling rich environmental storytelling and puzzles.


Task Block: Phase 7: Narrative Generation and Event Log
Task 17: 📚 7.1 Event Log Model (Story Log, i18n, Guild-Scoped).
Description: Model for storing a detailed log of game events within each guild. (Renamed from 5.1, moved).
Implement the `StoryLog` model (0.2/7). Fields: `id` (PK), `guild_id` (BIGINT, Indexed, FK to GuildConfig), `timestamp` (DATETIME, auto-now-add), `turn_number` (INTEGER, Nullable), `location_id` (INTEGER FK, Nullable), `event_type` (ENUM `EventType`), `entity_ids_json` (JSONB - e.g., `{"player_ids": [...], "npc_ids": [...], "item_ids": [...]}` - references to primary involved entities by ID and type for quick indexing/lookup), `details_json` (JSONB - full event details, including parameters, outcomes, check results, for rollback, feedback, and AI context), `narrative_i18n` (JSONB, optional, for AI-generated narrative embellishment of this event - Task 7.2).
Implement the `log_event(session: AsyncSession, guild_id: int, event_type: EventType, details_json: Dict[str, Any], entity_ids_json: Optional[Dict[str, List[int]]] = None, player_id: Optional[int] = None, party_id: Optional[int] = None, location_id: Optional[int] = None, turn_number: Optional[int] = None, narrative_i18n: Optional[Dict[str, str]] = None)` API: Saves a record to `StoryLog` within the provided transaction (session), SPECIFYING THIS `guild_id`. Ensure `entity_ids_json` is structured consistently. Called by all modules that change state or produce important events.
Result: `StoryLog` model defined, comprehensive API for logging all significant game events within a guild implemented, supporting detailed context for game mechanics and narrative.


Task 18: 📚 7.2 AI Narrative Generation (Multilang).
Description: **A to Z Implementation**: Develop a module to call an LLM for generating immersive, freeform narrative text (e.g., detailed event descriptions, NPC reactions, environmental flavor text) based on game context.
    - **API**: `generate_narrative(session, guild_id: int, context_event_log: StoryLog, generation_type: str, target_language: str, additional_context: Optional[Dict[str, Any]] = None) -> str`.
        - `context_event_log`: The primary `StoryLog` entry that this narrative will embellish or relate to.
        - `generation_type`: e.g., "event_elaboration", "npc_reaction_to_event", "location_ambiance_update".
        - `target_language`: Specific language for generation.
        - `additional_context`: Any other relevant data not in `context_event_log.details_json`.
    - **Prompt Engineering**:
        - Use AI Prompt Preparation Module (Task 2.2) to construct a detailed prompt.
        - Context should include:
            - Key details from `context_event_log.details_json` and `entity_ids_json`.
            - Relevant `WorldState` for the guild.
            - Current `Location` details if applicable.
            - Involved entities' key characteristics (names, types, brief descriptions from DB).
            - `RuleConfig` entries defining narrative style, tone, or forbidden themes for the guild (e.g., `ai:narrative:style:<generation_type>`).
        - Request generation in the `target_language`.
    - **LLM Interaction**:
        - Make a call to the configured LLM (OpenAI API or other) via `ai_orchestrator.make_real_ai_call`.
        - Implement robust error handling for API calls (timeouts, rate limits, content filters).
    - **Output Processing**:
        - Basic sanitization of LLM output (e.g., remove extraneous formatting, ensure it fits display constraints).
        - Optionally, store the generated narrative in `context_event_log.narrative_i18n` if the API is designed to update the log, or return it for the caller to use/store.
    - **Configurability**: Allow `RuleConfig` to enable/disable AI narrative generation globally or per `generation_type` for a guild.
Result: A robust API for generating dynamic, contextually relevant, and multilingual narrative text on demand, enriching the player experience.


Task 19: 📚 7.3 Turn and Report Formatting (Guild-Scoped). (Also Task 54)
Description: **A to Z Implementation**: Develop a comprehensive module that transforms structured event data (from `StoryLog`) into readable, localized reports for players and the Game Master.
    - **API**:
        - `format_log_entry_for_display(session, log_entry: StoryLog, target_language: str, perspective_entity_id: Optional[int] = None, perspective_entity_type: Optional[RelationshipEntityType] = None) -> str`. Formats a single log entry into a human-readable string. `perspective_entity_id` helps tailor information visibility if needed (e.g., hiding details unknown to that entity).
        - `format_turn_report_for_player(session, guild_id: int, player_id: int, turn_number: int, target_language: str) -> str`. Collects all relevant `StoryLog` entries for a player for a given turn and formats them into a cohesive report.
        - `format_master_event_summary(session, log_entry: StoryLog, target_language: str) -> str`. (Optional) A more detailed format for GMs.
    - **Localization**:
        - Use `localization_utils.get_localized_text` for all UI strings and templates.
        - Use `localization_utils.get_localized_entity_name` (and batch version) to fetch i18n names for all entities referenced in log entries (players, NPCs, items, locations, etc.) using their IDs and types stored in `StoryLog.entity_ids_json`.
        - Load term definitions (e.g., for skills, statuses, event types) from `RuleConfig` (e.g., `terms:event_names:<event_type>:<lang>`, `terms:skill_names:<skill_id>:<lang>`) for the `target_language`.
    - **Template Engine (Conceptual)**:
        - For each `EventType`, define message templates (stored in `RuleConfig` under keys like `report_templates:<event_type>:<lang>`).
        - Templates use placeholders for dynamic data from `log_entry.details_json` and localized entity names.
        - Example template for `MOVEMENT`: `"{player_name} moved from {old_location_name} to {new_location_name}."`
    - **Data Extraction & Formatting Logic (`_format_log_entry_with_names_cache` or similar internal function)**:
        - For each `StoryLog` entry:
            - Extract all referenced entity IDs from `entity_ids_json`.
            - Batch-fetch their localized names.
            - Based on `log_entry.event_type`, select the appropriate template from `RuleConfig`.
            - Populate the template with data from `details_json` and the fetched localized names.
            - Handle complex `details_json` structures (e.g., for combat results, check outcomes) by recursively formatting them or using sub-templates.
    - **Information Hiding (Perspective)**: If `perspective_entity_id` is provided, filter out details from the log entry that should not be visible to that entity (e.g., hidden NPC thoughts, outcomes of checks another player failed). This requires rules in `RuleConfig` about information visibility.
    - **Error Handling**: Gracefully handle missing templates, terms, or entity names, falling back to default messages or raw data display.
Result: A comprehensive and flexible logging and feedback formatting system capable of generating clear, detailed, and localized reports for players and GMs from any game event.


Task Block: Phase 3: Abilities and Checks Mechanics
Task 20: 🧠 3.1 Ability Model (i18n, Guild-Scoped).
Description: Define the model for storing ability data, supporting guild-specific and global abilities.
Implement the `Ability` model (0.2/7). Fields: `id` (PK), `guild_id` (BIGINT, Indexed, FK to GuildConfig, Nullable - if null, it's a global/system ability), `static_id` (TEXT, unique within `guild_id` if not null, globally unique if `guild_id` is null), `name_i18n` (JSONB), `description_i18n` (JSONB), `ability_type` (TEXT ENUM: e.g., "COMBAT_ACTIVE", "COMBAT_PASSIVE", "UTILITY", "SOCIAL"), `properties_json` (JSONB - detailed definition of effects, costs, targeting, requirements, cooldowns, presentation (e.g., animation/sound keys)).
Ensure unique constraint on (`guild_id`, `static_id`) allows `guild_id` to be NULL.
Result: `Ability` model defined, capable of storing diverse abilities with detailed mechanics and supporting both guild-specific and global scopes.


Task 21: 🧠 3.2 Entity Status Model (Status Effects, i18n, Guild-Scoped).
Description: Define models for storing status effect definitions and tracking active statuses on entities.
    - **`StatusEffectDefinition` Model (0.2/7)**: Defines a type of status effect.
        - Fields: `id` (PK), `guild_id` (BIGINT, Indexed, FK to GuildConfig, Nullable - for global statuses), `static_id` (TEXT, unique like Ability), `name_i18n` (JSONB), `description_i18n` (JSONB), `status_type` (TEXT ENUM: e.g., "BUFF", "DEBUFF", "NEUTRAL", "DOT", "HOT", "CONTROL"), `max_stacks` (INTEGER, default 1), `is_permanent` (BOOLEAN, default False), `properties_json` (JSONB - detailed mechanics: stat modifications (e.g., `{"stats_add": {"strength": 5}, "stats_mult": {"attack_speed": 0.1}}`), periodic effects (damage/heal), behavioral changes, dispel conditions, visual effect keys).
    - **`ActiveStatusEffect` Model (0.2/7)**: Represents an instance of a status effect applied to an entity.
        - Fields: `id` (PK), `guild_id` (BIGINT, Indexed, FK to GuildConfig), `target_entity_id` (INTEGER), `target_entity_type` (ENUM `RelationshipEntityType`), `status_effect_definition_id` (INTEGER FK to `StatusEffectDefinition`), `applied_at` (DATETIME), `duration_turns` (INTEGER, nullable for permanent), `remaining_turns` (INTEGER, nullable), `current_stacks` (INTEGER, default 1), `source_entity_id` (INTEGER, nullable), `source_entity_type` (ENUM `RelationshipEntityType`, nullable), `source_ability_id` (INTEGER FK to `Ability`, nullable), `instance_properties_json` (JSONB, for variations of this specific instance, e.g., variable DoT damage).
        - Indexed on (`target_entity_type`, `target_entity_id`).
Result: Models for status effect definitions and their active instances on entities are defined, supporting detailed mechanics, duration, stacking, and guild-scoping.


Task 22: 🧠 3.3 API for Activating Abilities and Applying Statuses (Guild-Scoped).
Description: **A to Z Implementation**: Implement the comprehensive logic for entities using abilities and for applying/removing status effects, fully driven by `RuleConfig` and ability/status definitions.
    - **API `activate_ability(session, guild_id: int, actor_id: int, actor_type: RelationshipEntityType, ability_static_id_or_db_id: Union[str, int], primary_target_ids_and_types: Optional[List[Tuple[int, RelationshipEntityType]]] = None, chosen_sub_options_json: Optional[Dict[str, Any]] = None) -> AbilityOutcomeDetails`**:
        - **Load Data**: Load `Ability` definition (by `static_id` or `db_id`, respecting `guild_id` or global). Load actor entity.
        - **Pre-activation Checks (from `Ability.properties_json.requirements` and `RuleConfig`)**:
            - Cooldowns, resource costs (HP, MP, stamina - deduct from actor if checks pass).
            - Required items, statuses on actor/target, player state (e.g., "must_be_in_combat").
            - Line of sight, range to target(s).
            - Skill checks if ability itself requires one to cast (call Check Resolver Task 6.3.2).
        - **Targeting**: Resolve targets based on `Ability.properties_json.targeting_rules` (e.g., "self", "single_enemy", "all_allies_in_range", "area_at_point") and `primary_target_ids_and_types`. This may involve complex queries or spatial checks.
        - **Effect Execution (iterate `Ability.properties_json.effects` list)**:
            - For each effect (e.g., "damage", "heal", "apply_status", "summon_entity", "modify_world_state"):
                - Determine affected targets for this specific effect.
                - Perform calculations based on effect properties, actor's effective stats (Task related to 6.3.2), and `RuleConfig` (e.g., damage formulas, resistance/vulnerability checks). This may involve further calls to Check Resolver (e.g., saving throws for targets).
                - Update target entity states (HP, stats, apply/remove `ActiveStatusEffect` records via `apply_status` API).
                - Update actor state (e.g., set cooldowns).
        - **`AbilityOutcomeDetails`**: Populate with comprehensive results: caster, targets, actual effects applied (damage dealt, healing done, statuses applied with durations, resources spent), any check results.
        - **Logging**: Log `ABILITY_USED` event to `StoryLog` with full `AbilityOutcomeDetails`.
    - **API `apply_status(session, guild_id: int, target_entity_id: int, target_entity_type: RelationshipEntityType, status_definition_static_id_or_db_id: Union[str, int], duration_turns: Optional[int], source_actor_id: Optional[int], source_actor_type: Optional[RelationshipEntityType], source_ability_id: Optional[int], instance_properties_json: Optional[Dict[str, Any]]) -> bool`**:
        - Load `StatusEffectDefinition`.
        - Check stacking rules (`max_stacks`, `RuleConfig` for how stacks interact).
        - If stackable and existing `ActiveStatusEffect` of same type found: increment `current_stacks`, refresh duration per `StatusEffectDefinition.properties_json.duration_refresh_on_reapply` rule.
        - If not stackable or no existing, create new `ActiveStatusEffect`.
        - Log `STATUS_APPLIED` event.
    - **API `remove_status(session, guild_id: int, active_status_id: int) -> bool`**: Remove an `ActiveStatusEffect`. Log `STATUS_REMOVED`.
    - **Status Tick System (Conceptual - may be part of Turn Controller or separate)**: Logic to process active statuses each turn/round (decrement `remaining_turns`, apply periodic effects like DoT/HoT, check for expiration).
    - **Error Handling**: Graceful error handling for all failure conditions (invalid ability/status, unmet requirements, invalid targets).
Result: A complete system for ability activation and status effect management, deeply integrated with game rules, entity stats, and event logging, providing rich tactical possibilities.


Task Block: Phase 4: World and Location Model
Task 23: 🗺️ 4.1 Location Model (i18n, Guild-Scoped).
* Description: (Moved from 13 for better grouping). Define the location model in the DB, linked to a guild, with multilingual support and relationships. This model will store both static and generated location details. (See description in Task 1.1 - tasks are identical and cover model definition).
Result: Location model defined, static data accessible and isolated.

Task 24: 🗺️ 4.2 Guild Map Generation and Editing (Guild-Scoped).
* Description: **A to Z Implementation**: Implement comprehensive AI-driven new location generation and robust Game Master tools for manual map management.
    - **AI Location Generation (`generate_new_location_ai`)**:
        - API: `generate_new_location_ai(session, bot, guild_id: int, generation_context: Dict[str, Any])`. Context can include: connecting `Location.id` (to generate adjacent), desired `LocationType`, theme keywords, difficulty hints.
        - Calls AI Prompt Preparation (Task 2.2) to generate a detailed prompt for a *new* location (name, description, type, coordinates relative to context or absolute, potential interactive elements, initial NPC/item placements, suggested connections to existing locations with connection types).
        - Trigger AI generation and moderation flow (Task 2.6). The `parsed_validated_data_json` from an approved `PendingGeneration` (containing `ParsedLocationData`) will be used.
        - **Saving**: After approval, the `save_approved_generation` (Task 2.6) logic must correctly create the new `Location` record, establish `neighbor_locations_json` links (two-way if applicable) with specified existing locations, and populate `generated_details_json` (interactive elements, sublocations) and any initial entities (NPCs, items) also generated by AI for this new location.
    - **Master Map Editing Commands (Discord - part of Task 15.1)**:
        - `/master_map create_location <name_i18n_json> [type] [static_id] ...`: Manually create a new `Location`.
        - `/master_map update_location <location_id_or_static_id> <field> <value_json>`: Update any field of an existing `Location`.
        - `/master_map delete_location <location_id_or_static_id>`: Delete a location (handle entities within, re-routing connections if possible, or warning Master).
        - `/master_map connect_locations <loc1_id_or_static_id> <loc2_id_or_static_id> <connection_type_i18n_json> [is_two_way=True] [conditions_json]`: Create/update connections in `neighbor_locations_json` for both locations. `conditions_json` could specify requirements (item, quest state) to use the connection.
        - `/master_map disconnect_locations <loc1_id_or_static_id> <loc2_id_or_static_id>`: Remove connection.
        - `/master_map set_coordinates <location_id_or_static_id> <coordinates_json>`
        - `/master_map manage_interactive_element <location_id_or_static_id> <element_id_or_name> [action:add/update/remove] [details_json]`: Manage elements in `Location.generated_details_json.interactive_elements`.
    - **Data Integrity**: All operations must maintain consistency of the map graph (e.g., reciprocal connections in `neighbor_locations_json` if two-way).
    - **Logging**: All map generation and editing actions logged to `StoryLog`.
Result: A comprehensive system for both AI-driven procedural expansion and manual curation of the guild-specific game world map, ensuring data integrity and detailed logging.

Task 25: 🗺️ 4.3 Location Transitions (Guild-Scoped).
* Description: **A to Z Implementation**: Fully implement player and party movement between locations. (This task is identical to Task 1.3. The detailed "A to Z" description provided for Task 1.3 applies here.)
* API function `handle_move_action(guild_id: int, session: Session, player_id: int, target_location_identifier: str) -> dict`. Called from Action Processing Module (Task 6.11).
* Result: A robust, rule-driven movement system supporting individual and party travel, with integrated checks, costs, event logging, and hooks for dynamic content.


Task Block: Phase 5: Combat System
Task 26: ⚔️ 5.1 Combat and Participant Model (Guild-Scoped).
Description: Define the model for tracking the state of active combat within a guild.
Implement the `CombatEncounter` model (0.2/7). Fields: `id` (PK), `guild_id` (BIGINT, FK), `location_id` (INTEGER FK), `status` (ENUM `CombatStatus`: e.g., `ACTIVE`, `PLAYER_VICTORY`, `NPC_VICTORY`, `ENDED_DRAW`), `start_time` (DATETIME), `end_time` (DATETIME, Nullable), `current_turn_number` (INTEGER, default 1), `current_round_number` (INTEGER, default 1), `current_turn_entity_id` (INT), `current_turn_entity_type` (ENUM `RelationshipEntityType`), `turn_order_json` (JSONB: list of `{"entity_id": int, "entity_type": str, "initiative_roll": int}`), `rules_config_snapshot_json` (JSONB: snapshot of relevant combat rules from `RuleConfig` at combat start, e.g., crit rules, damage type modifiers), `participants_json` (JSONB: list of participant objects, each containing `entity_id`, `entity_type`, `team_id` (e.g., "players", "monsters", "faction_A"), `initial_hp`, `current_hp`, `initial_resources_json`, `current_resources_json`, `initial_statuses_json`, `active_statuses_json` (simplified list for quick access, full state in `ActiveStatusEffect` table)), `combat_log_json` (JSONB: turn-by-turn log of actions, damage, checks within this specific combat, for detailed playback or analysis).
Result: A comprehensive `CombatEncounter` model capable of storing all necessary state for managing complex, multi-participant combat scenarios.


Task 27: ⚔️ 5.2 Combat Engine Module.
Description: **A to Z Implementation**: Implement the central module for calculating and applying the outcomes of all actions performed during combat, fully driven by `RuleConfig`.
    - **API**: `process_combat_action(session, guild_id: int, combat_instance_id: int, actor_id: int, actor_type: RelationshipEntityType, action_data: Dict[str, Any]) -> CombatActionResult`.
        - `action_data`: Contains `action_type` (e.g., "attack", "cast_ability", "use_item", "defend", "flee"), `target_id`, `target_type`, `ability_id`/`item_id` if applicable, etc.
    - **Data Loading**: Load `CombatEncounter`, actor, and target(s) data. Use `CombatEncounter.rules_config_snapshot_json` and current `RuleConfig` for rules.
    - **Action Processing (Dispatch based on `action_data.action_type`)**:
        - **Attack**:
            - Perform attack roll (Check Resolver Task 6.3.2) against target's defense (e.g., AC, evasion stat).
            - Calculate damage based on weapon, actor's stats, ability modifiers, target's resistances/vulnerabilities (from `RuleConfig`, `Item.properties_json`, `StatusEffectDefinition.properties_json`). Apply critical hit rules.
        - **Cast Ability**: Call Ability System (Task 3.3 `activate_ability`) with combat context. `activate_ability` handles costs, targeting, effects, and returns details for `CombatActionResult`.
        - **Use Item**: Validate item usability in combat. Apply item effects (e.g., healing potion, grenade). Update item quantity in inventory.
        - **Defend/Dodge**: Apply temporary status effect (e.g., "defending" giving bonus to defense for 1 round) or set a flag for next incoming attack.
        - **Flee**: Perform check (e.g., opposed by fastest enemy) based on `RuleConfig`. If successful, actor exits combat.
        - **Other Actions**: Support for other tactical actions as defined by rules.
    - **State Updates**:
        - Update `current_hp`, `current_resources_json`, `active_statuses_json` for all affected participants within `CombatEncounter.participants_json`.
        - If an entity's HP drops to 0 or below, mark them as "defeated" in `participants_json`.
    - **Logging**:
        - Append detailed action results (dice rolls, damage, status changes) to `CombatEncounter.combat_log_json`.
        - Log significant events (e.g., `COMBAT_ACTION`, `ENTITY_DEFEATED`) to global `StoryLog` (Task 7.1), including the `CombatActionResult`.
    - **`CombatActionResult`**: Return a comprehensive Pydantic model detailing the action's success, numerical outcomes (damage, healing), status changes, check results, and a descriptive message key for localization.
    - **Error Handling**: Gracefully handle invalid actions, targets, or rule configurations.
Result: A detailed, reliable, and highly configurable combat engine that accurately calculates and applies the outcomes of all combat actions, maintaining combat state and providing comprehensive logging.


Task 28: ⚔️ 5.3 NPC Combat Strategy Module (AI).
Description: **A to Z Implementation**: Implement sophisticated AI logic governing NPC actions in combat, driven by `RuleConfig` and dynamic combat conditions.
    - **API**: `get_npc_combat_action(session, guild_id: int, npc_id: int, combat_instance_id: int) -> Dict[str, Any]` (returns `action_data` for Task 5.2).
    - **Context Gathering**:
        - Load NPC data (`GeneratedNpc` model, including `properties_json` for stats, abilities, personality tags like "aggressive", "cautious", "healer").
        - Load current `CombatEncounter` state (participants, turn order, environment if relevant).
        - Load NPC's relationships (Task 34) with all other combat participants.
        - Load NPC's current active status effects.
    - **Rule Loading**: Fetch AI behavior rules from `RuleConfig` for this `guild_id` (e.g., `ai:combat_strategy:<npc_type_or_role>`, `ai:combat_strategy:default`). Rules define:
        - Targeting priorities (e.g., "lowest_hp_percent", "highest_threat", "focus_healers", "protect_allies").
        - Action selection logic (conditions for using specific abilities, items, or standard actions like attack/defend).
        - Risk assessment (e.g., when to flee, when to use defensive abilities).
        - Preferred engagement range.
    - **Target Selection**:
        - Identify valid targets based on ability/attack ranges and visibility.
        - Evaluate potential targets based on rules: threat level (damage output, crowd control effects), vulnerability, relationship status (prioritize enemies, avoid harming allies unless specific tactic), current HP, key roles (healer, damage dealer).
    - **Action Choice**:
        - Evaluate available actions: standard attack, special abilities (check resources, cooldowns), usable items from NPC's inventory (if simulated).
        - For each action-target pair, simulate potential outcome/effectiveness (e.g., using a simplified Check Resolver or heuristics based on chance-to-hit, expected damage/effect).
        - Select the action that maximizes utility based on NPC's current state (HP, resources), personality, role (damage, support, tank), and strategic goals defined in rules (e.g., "eliminate_weakest_first", "debuff_strongest_enemy", "heal_lowest_ally").
        - Consider synergy between abilities or with allied NPCs.
    - **Scalability & Adaptability**: AI behavior should scale with encounter difficulty, NPC level, or party strength, as defined in `RuleConfig`. NPCs might change tactics based on combat progression (e.g., more desperate actions at low HP).
    - **Output**: Return a dictionary describing the chosen action in the format expected by Combat Engine (Task 5.2).
    - **Logging**: Log NPC's decision-making process (key factors, chosen action/target) for debugging and analysis (internal log, not `StoryLog`).
Result: A dynamic and configurable NPC combat AI capable of making intelligent tactical decisions based on a wide range of factors, providing challenging and varied combat encounters.


Task 29: ⚔️ 5.4 Combat Cycle Refactoring (Multiplayer Combat State Machine).
Description: **A to Z Implementation**: Develop a robust Combat Cycle Manager to orchestrate turn-based or round-based combat from initiation to conclusion, integrating player and NPC actions, and handling all state transitions and consequences.
    - **API `start_combat(session, guild_id: int, location_id: int, initiating_player_id: Optional[int], participant_entities: List[Union[Player, GeneratedNpc, Party]]) -> CombatEncounter`**:
        - Called by Action Processor (Task 6.11) or system events.
        - Within an **atomic transaction**:
            - Create `CombatEncounter` record (Task 26) with `guild_id`, `location_id`.
            - Populate `participants_json` with all involved entities (resolve parties to individual players), their initial HP/resources (from base stats + current active statuses), team affiliations.
            - Determine initiative for all participants (call Check Resolver Task 6.3.2 with agility/perception checks based on `RuleConfig`). Sort entities into `turn_order_json`.
            - Set first turn: `current_turn_entity_id/type`, `current_turn_number=1`, `current_round_number=1`.
            - Snapshot relevant combat rules from `RuleConfig` into `CombatEncounter.rules_config_snapshot_json`.
            - Update `Player.current_status` / `Party.turn_status` to `IN_COMBAT`.
            - Log `COMBAT_START` event to `StoryLog`.
        - Return the created `CombatEncounter`.
    - **API `process_combat_turn(session, guild_id: int, combat_id: int, player_action_data: Optional[Dict[str, Any]] = None) -> CombatEncounter`**:
        - Called by Action Processor (if player turn with `player_action_data`) or internally for NPC turns.
        - Load `CombatEncounter`. If status is not `ACTIVE`, return.
        - **If current turn is Player**:
            - If `player_action_data` is provided, process it using Combat Engine (Task 5.2 `process_combat_action`).
            - If no action (e.g., player disconnected or timed out by `RuleConfig`), process as a "delay" or "pass" action.
        - **If current turn is NPC**:
            - Call NPC Combat Strategy (Task 5.3 `get_npc_combat_action`) to get NPC's action.
            - Process the NPC action using Combat Engine (Task 5.2).
        - **After any action**:
            - Update `CombatEncounter` (participants' state, combat log) based on `CombatActionResult`.
            - Log action to global `StoryLog`.
            - Provide localized feedback to relevant players (Task 7.3/54).
        - **Check for Combat End (`_check_combat_end_condition`)**:
            - Evaluate if combat has ended (e.g., all members of one team defeated, key NPC defeated, morale break based on `RuleConfig`).
            - If ended, set `CombatEncounter.status` (e.g., `PLAYER_VICTORY`), call `_handle_combat_end_consequences`.
        - **Advance Turn (`_advance_turn_in_combat`)**:
            - If combat not ended, determine next entity in `turn_order_json` (skip defeated).
            - Update `CombatEncounter.current_turn_entity_id/type`, increment `current_turn_number`/`current_round_number`.
            - If next turn is NPC, recursively call `process_combat_turn` or schedule it.
            - If next turn is Player, control returns (Action Processor will await next player input).
    - **API `_handle_combat_end_consequences(session, guild_id: int, combat_encounter: CombatEncounter)`**:
        - Determine winning/losing teams and involved players.
        - **XP**: Call Experience System (Task 13.2 `award_xp`) for victors, based on `RuleConfig` (XP for defeated enemies, objectives).
        - **Loot**: Generate and distribute loot.
            - Determine loot from defeated NPCs (from their `InventoryItem` or generated based on `RuleConfig` `loot_tables:<npc_type>`).
            - Distribute among victors according to `RuleConfig` (e.g., need/greed rolls, leader distribution, random assignment). This may involve creating `InventoryItem` records.
            - Handle cases where loot is placed in location if no one can carry.
        - **Relationships**: Call Relationship System (Task 8.4 `update_relationship`) based on combat outcomes (e.g., player vs. NPC faction, player vs. specific NPC).
        - **WorldState**: Update relevant `RuleConfig` flags (e.g., `worldstate:npc_defeated:<npc_static_id>`).
        - **Quest Progress**: Call Quest System (Task 9.3 `handle_player_event_for_quest`) with `COMBAT_END` event context.
        - Update `Player.current_status` / `Party.turn_status` from `IN_COMBAT` to `EXPLORING` or `IDLE`.
        - Log `COMBAT_END_CONSEQUENCES_APPLIED` event.
    - **Error Handling**: Robust error handling for all operations.
Result: A fully functional combat state machine that manages the entire lifecycle of combat encounters, from initiation through action resolution to consequence application, driven by game rules and interacting with all relevant systems.


Task Block: Phase 13: Experience and Character Development System
Task 30: ⚡️ 13.1 Experience System Structure (Rules).
* Description: Define the comprehensive structure for all experience and leveling rules within `RuleConfig` for each guild. This includes:
    - `experience_system:xp_gain_rules:<event_type>`: Defines base XP, scaling factors (player level, target level difference), and distribution policies for events like `combat_victory:<enemy_category>`, `quest_completed:<quest_type>`, `skill_usage:<skill_name>`, `discovery:<discovery_type>`.
    - `experience_system:level_curve`: Array defining XP needed for each level (e.g., `[{"current_level": 1, "xp_to_reach_next_level": 1000}, ...]`).
    - `experience_system:level_up_rewards`: Defines default and level-specific rewards (attribute points, skill points, new abilities unlocked via `static_id`, special feature flags).
    - `character_attributes:definitions`: Defines all available attributes (e.g., "strength", "intelligence") with `name_i18n`, `description_i18n`, min/max values.
    - `character_attributes:base_values`: Default starting values for attributes.
    - `character_attributes:cost_per_point`: Formula or tiered cost for increasing attributes during level up.
    - `skills:definitions`: Similar to attributes, for skills.
    - `skills:base_values` and `skills:cost_per_point`.
Result: A clear and comprehensive definition of all `RuleConfig` keys and their JSON structures required to govern the entire experience and character development system.

Task 31: ⚡️ 13.2 XP Awarding and Progress.
* Description: **A to Z Implementation**: Implement the complete logic for awarding XP from all sources and tracking player progress towards leveling up, fully driven by `RuleConfig`.
    - **API**: `award_xp(session, guild_id: int, primary_entity_id: int, primary_entity_type: RelationshipEntityType, xp_source_event_type: EventType, xp_source_details: Dict[str, Any], source_log_id: int)`.
        - `xp_source_details`: Contains context for calculating XP (e.g., for combat: list of defeated enemies, their levels; for quest: quest difficulty, type).
    - **XP Calculation**:
        - Load `RuleConfig` for `experience_system:xp_gain_rules:<xp_source_event_type.name>`.
        - Calculate base XP based on `xp_source_details` and rules (e.g., sum XP from multiple defeated enemies).
        - Apply all relevant scaling factors (player level vs. content level, party size modifiers, bonus XP from statuses/items).
    - **XP Distribution**:
        - Determine all recipient players. If `primary_entity_type` is `PARTY`, get all eligible members from `Party.player_ids_json`.
        - Apply `RuleConfig` distribution policy (e.g., `even_split`, `performance_based_modifier_from_combat_logs`, `leader_gets_bonus`).
    - **DB Update & Level Check**:
        - For each recipient player:
            - Atomically add calculated XP to `Player.xp`.
            - Call `_check_for_level_up(session, guild_id, player)`:
                - Continuously check `player.xp` against `experience_system:level_curve` from `RuleConfig`.
                - If level up: increment `Player.level`, subtract XP cost, award `Player.unspent_xp` and other rewards (new abilities, features) based on `experience_system:level_up_rewards` from `RuleConfig`. Log `LEVEL_UP` event. Notify player. Repeat if multiple levels gained.
    - **Event Logging**: Log `XP_GAINED` event to `StoryLog` for each player, detailing source, amount, and final XP total.
    - **Feedback**: Provide localized feedback to players about XP gained and level ups.
Result: A comprehensive XP system that accurately awards and distributes experience from all game activities, handles level progression, and grants rewards according to flexible, guild-specific rules.

Task 32: ⚡️ 13.3 Applying Level Up (Multy-i18n).
* Description: **A to Z Implementation**: Implement player commands and underlying logic for spending accumulated points (`Player.unspent_xp` or other point types like `unspent_skill_points` if modeled) to improve character attributes, skills, or unlock choices, all governed by `RuleConfig`.
    - **Player Commands (Discord)**:
        - `/levelup attribute <attribute_name> <points_to_spend>`
        - `/levelup skill <skill_name> <points_to_spend>`
        - `/levelup choice <choice_id_from_levelup_rewards>` (e.g., for choosing one of two abilities offered at a certain level).
    - **API `spend_character_points(session, guild_id: int, player_id: int, point_type: str, target_name: str, points_to_spend: int) -> SpendPointsResult`**:
        - `point_type`: e.g., "attribute", "skill".
        - `target_name`: e.g., "strength", "swordsmanship".
        - Load player, `RuleConfig` for `character_attributes:definitions`, `character_attributes:cost_per_point` (or skill equivalents).
        - Validate `target_name`, sufficiency of `points_to_spend` against `Player.unspent_xp` (or other point fields), and cost per point.
        - Update `Player.attributes_json` (or `skills_json`, or grant abilities/items based on `target_name` for "choice" type).
        - Deduct spent points from `Player.unspent_xp`.
        - Log `ATTRIBUTE_POINTS_SPENT` or `SKILL_POINTS_SPENT` event.
    - **Effective Stats Recalculation**: Ensure that any change to base attributes/skills triggers a recalculation or invalidation of cached "effective stats" if such a caching system exists (related to Task 6.3.2).
    - **Feedback**: Provide detailed, localized feedback via Discord commands on success (new stat/skill values, remaining points) or failure (invalid target, not enough points, etc.).
    - **i18n**: All attribute/skill names and command feedback must be localized.
Result: A complete system allowing players to meaningfully develop their characters by spending level-up points according to guild-specific rules, with clear feedback.


Task Block: Phase 8: Factions, Relationships, and Social Mechanics
Task 33: 🎭 8.1 Factions Model (Guild-Scoped, i18n).
Description: Define the model for storing faction data within a guild, including their ideology, resources, leadership, and AI generation metadata.
Implement the `GeneratedFaction` model (0.2/7). Fields: `id` (PK), `guild_id` (BIGINT, FK), `static_id` (TEXT, unique within guild), `name_i18n` (JSONB), `description_i18n` (JSONB), `ideology_i18n` (JSONB: summary of beliefs/goals), `banner_url` (TEXT, Optional), `leader_npc_id` (INTEGER FK to `GeneratedNpc.id`, Nullable), `member_npc_ids_json` (JSONB: List of `GeneratedNpc.id`s that are prominent members, for quick reference), `resources_json` (JSONB: abstract representation of faction wealth, manpower, territory influence), `ai_metadata_json` (JSONB: data used for or resulting from AI generation, e.g., personality tags, generation prompt hints).
Result: `GeneratedFaction` model defined, capable of storing detailed information about game factions.

Task 34: 🎭 8.2 Relationships Model (Guild-Scoped).
Description: Define the model for storing quantified relationships (positive/negative standing, specific types like "allied", "rival", "feared_by") between various game entities (Players, Parties, NPCs, Factions) within a guild.
Implement the `Relationship` model (0.2/7). Fields: `id` (PK), `guild_id` (BIGINT, FK), `entity1_id` (INTEGER), `entity1_type` (ENUM `RelationshipEntityType`), `entity2_id` (INTEGER), `entity2_type` (ENUM `RelationshipEntityType`), `relationship_type` (TEXT, e.g., "personal_feeling", "faction_standing_official", "trade_reputation", default "neutral"), `value` (INTEGER, e.g., -100 to 100), `source_log_id` (INTEGER FK to `StoryLog.id`, Nullable, for tracking the event that last significantly changed this relationship).
Implement `UniqueConstraint("guild_id", "entity1_id", "entity1_type", "entity2_id", "entity2_type", "relationship_type")` to allow multiple types of relationships between the same pair of entities. Ensure `_get_canonical_entity_pair` in `relationship_system.py` correctly handles this if `relationship_type` becomes part of the key for fetching a specific relationship.
Result: `Relationship` model defined, allowing for detailed tracking of nuanced social dynamics between game entities.

Task 35: 🎭 8.3 AI Generation of Factions and Relationships (Multilang, Per Guild).
Description: **A to Z Implementation**: Enable AI to generate a cohesive set of factions and their initial inter-relationships (and key NPC-to-faction relationships) for a guild, based on `RuleConfig` and world lore.
    - **Trigger**: Part of initial world generation (Task 10 in old numbering) or triggered by Game Master / game events.
    - **Prompt Preparation (Task 2.2)**: Generate a prompt requesting a set of factions (names, descriptions, ideologies, potential leaders) and a matrix of their initial relationships (e.g., Faction A is "allied" with Faction B, "hostile" to Faction C). Prompt should include `RuleConfig` constraints (number of factions, allowed ideologies, conflict likelihood: `ai:generation:faction_ecosystem:*`).
    - **AI Call & Parsing (Task 2.3, 2.6)**:
        - Invoke LLM.
        - Parse response into `ParsedFactionData` and `ParsedRelationshipData` objects. Validate thoroughly.
    - **Saving (Task 2.6 `save_approved_generation` extension)**:
        - **Pass 1: Save Factions**: Create `GeneratedFaction` records. Store `static_id` to `db_id` mapping.
        - **Pass 2: Save Relationships**:
            - For inter-faction relationships, use the `static_id` map to find `db_id`s and create `Relationship` records.
            - If AI suggests NPC leaders and their faction alignment, create/update `GeneratedNpc` records (if part of same generation batch) and link them via `GeneratedFaction.leader_npc_id` and create corresponding NPC-to-Faction `Relationship` records.
    - **i18n**: Ensure all generated text fields (`name_i18n`, `description_i18n`, etc.) are created in required languages.
    - **Logging**: Log `FACTIONS_GENERATED` and `RELATIONSHIPS_INITIALIZED_AI` events.
Result: A system capable of AI-generating a rich initial social landscape of factions and their relationships, providing a dynamic backdrop for gameplay.

Task 36: 🎭 8.4 Relationship Changes Through Actions (According to Rules, Guild-Scoped).
Description: **A to Z Implementation**: Implement the logic for updating numerical relationship values and types in response to all relevant game events, driven by flexible `RuleConfig` settings.
    - **API**: `update_relationship(session, guild_id: int, entity_doing_id: int, entity_doing_type: RelationshipEntityType, target_entity_id: int, target_entity_type: RelationshipEntityType, event_type: EventType, event_details: Dict[str, Any], source_log_id: int)`.
        - `event_details`: Provides specific context from the triggering event (e.g., damage dealt in combat, specific dialogue choice ID, item gifted in trade).
    - **Rule Loading**:
        - For the given `event_type.name`, load rules from `RuleConfig` (e.g., `relationship_rules:<EVENT_TYPE_NAME>`).
        - Rules specify:
            - `relationship_type_to_affect` (e.g., "personal_feeling", "faction_standing_official").
            - `delta_value` (fixed amount) or `delta_formula` (string to be `eval`ed with `event_details` and entity stats as context).
            - `conditions` (list of criteria that must be met in `event_details` or entity states for the rule to apply).
            - `min_val`, `max_val` for clamping.
            - `affects_faction_of_target`: If true, and target is NPC, also try to apply change between actor and target's faction.
            - `reciprocal_change_multiplier`: (e.g., -0.5 for "if A likes B more, B likes A a bit less due to perceived neediness").
    - **Relationship Update**:
        - Use `_get_canonical_entity_pair` to ensure consistent keying.
        - Find or create the `Relationship` record for the specified `relationship_type_to_affect`.
        - Calculate `delta` based on rule. Apply `delta` to `Relationship.value`, clamping with `min_val`/`max_val`.
        - Update `Relationship.source_log_id`.
    - **Faction Relationship Cascade**: If `affects_faction_of_target` and applicable, determine factions of `entity_doing` and `target_entity`. Recursively call `update_relationship` for the faction-to-faction or entity-to-faction relationship, using a modified `event_type` (e.g., `FACTION_PROXY_COMBAT_VICTORY`) and potentially different rules from `RuleConfig`.
    - **Logging**: Log `RELATIONSHIP_CHANGE` event to `StoryLog` with full details (both entities, type of relationship, old/new value, source event).
    - **Integration**: Ensure this API is called by all relevant modules: Combat (Task 5.4), Quests (Task 9.3), Dialogue (Task 11.2), Trade (Task 10.3), World Events (Task 14.2), Ability System (Task 3.3).
Result: A comprehensive system that dynamically adjusts relationships between all entity types based on game events and highly configurable rules, creating an evolving social simulation.

Task 37: 🎭 8.5 Relationship Influence (Full, According to Rules, Multy-i18n).
Description: **A to Z Implementation**: Fully integrate the use of `Relationship.value` (for various `relationship_type`s) from the DB as parameters or conditions in all relevant game mechanics, governed by `RuleConfig`.
    - **Check Resolver (Task 6.3.2)**:
        - When resolving checks, load relationships between actor and target (and potentially actor/target vs. other relevant entities like faction leaders).
        - `RuleConfig` (`checks:<check_type>:relationship_modifiers`) defines how relationship values (of specified types) translate to check modifiers (e.g., bonus/penalty to roll, change to DC). Formulas can be used.
    - **NPC Combat Strategy (Task 5.3)**:
        - NPC AI loads relationships with potential targets.
        - `RuleConfig` (`ai:combat_strategy:<npc_type>:relationship_behavior`) dictates:
            - Target selection preference (e.g., prioritize attacking hated enemies, avoid attacking allies/friends unless confused/berserk).
            - Action choice (e.g., use different abilities against friends vs. foes, hesitate to use lethal force on high-relationship targets).
    - **Dialogue System (Task 11.1, 11.2)**:
        - When generating NPC dialogue (Task 11.1), include relationship values in prompt context.
        - `RuleConfig` (`dialogue:relationship_influence`) defines:
            - NPC tone/greeting variations based on relationship level.
            - Availability of specific dialogue options or information disclosure.
            - NPC willingness to offer quests, trade, or services.
    - **Trade System (Task 10.3)**:
        - When calculating prices, load relationship between player and NPC trader.
        - `RuleConfig` (`economy:price_modifiers:relationship`) defines how relationship values affect buy/sell price multipliers.
    - **Quest System (Task 9.3)**:
        - Availability of quests from an NPC can depend on relationship with player/party.
        - Quest outcomes or specific step resolutions might be influenced by relationships with involved NPCs/factions.
    - **Action Processing (Task 6.11, 6.1.1)**:
        - Certain player actions (e.g., social interactions, persuasion attempts not covered by specific checks) might have outcomes modified by relationships.
    - **Feedback (Task 7.3/54)**: Ensure localized feedback to players clearly (or subtly, as per design) reflects how relationships influenced outcomes (e.g., "The guard seems friendlier towards you and offers a discount," "Your blatant aggression towards the Baron's men has made him wary.").
    - **Generic Utility**: Provide a utility `get_relationship_modifier(session, guild_id, entity1, entity2, context_key_for_rules)` that encapsulates loading relationships and applying rules for a specific context.
Result: A game world where social standing and past interactions meaningfully impact gameplay across all relevant systems, driven by configurable rules.

Task 38: 🎭 8.6 Complex Internal Faction Relationships.
Description: **A to Z Implementation**: Enable the generation and use of specific, potentially hidden or nuanced, NPC-to-NPC and NPC-to-Faction relationships within the game world, influencing NPC behavior and plot developments.
    - **AI Generation (Task 2.2, 2.3, 2.6, 35)**:
        - AI prompts for NPC generation can request details about their specific loyalties, rivalries, secret allegiances, or personal feelings towards other specific NPCs or Factions (even their own).
        - `ParsedNpcData` and `ParsedRelationshipData` should support capturing these nuanced relationships.
        - Saving logic must correctly create these `Relationship` records (e.g., NPC A "secretly_admires" NPC B; NPC C "distrusts_leader_of_own_faction" Faction X).
    - **Storage**: Store these as standard `Relationship` records, possibly using specific `relationship_type` values (e.g., "personal_grudge_npc_npc", "secret_loyalty_npc_faction").
    - **Influence on NPC Behavior**:
        - **NPC Combat Strategy (Task 5.3)**: AI rules in `RuleConfig` (`ai:combat_strategy:<npc_type>:internal_relationship_tactics`) can define how these hidden relationships affect combat choices (e.g., an NPC might hesitate to attack an admired enemy NPC, or might subtly assist the player against a distrusted faction member).
        - **Dialogue System (Task 11.1, 11.2)**: Hidden relationships can influence NPC dialogue choices, willingness to share information, or offer secret help/hindrance, if the LLM prompt is constructed to consider them.
        - **Global Entity Management (Task 14.2)**: Interactions between Global NPCs or Mobile Groups can be influenced by these specific relationships.
    - **Revealing Relationships**: Game events, player actions (investigation, social checks), or quest progression might reveal these hidden relationships to the player, potentially changing player's understanding or strategy. This involves updating `PlayerNpcMemory` or `WorldState`.
    - **`RuleConfig`**: Define keys for NPC archetypes or specific NPCs that describe how different internal relationship types should modify their standard behavior patterns.
Result: A richer social simulation where NPCs have complex interconnections that can lead to emergent behaviors, betrayals, unexpected alliances, and deeper plotlines.


Task Block: Phase 9: Detailed Quest System with Consequences
Task 39: 📚 9.1 Quest and Step Structure (Guild-Scoped, i18n).
Description: Define comprehensive ORM models for `Questline`, `GeneratedQuest`, `QuestStep`, and `PlayerQuestProgress`, ensuring `guild_id` for isolation, i18n for all text, and robust structures for complex quest logic.
    - **`Questline` Model**: `id`, `guild_id`, `static_id`, `title_i18n`, `description_i18n`, `starting_quest_static_id` (links to first `GeneratedQuest.static_id`), `is_main_storyline` (bool), `required_previous_questline_static_id` (for chaining storylines), `properties_json` (e.g., overall theme, recommended player level range).
    - **`GeneratedQuest` Model**: `id`, `guild_id`, `static_id`, `title_i18n`, `description_i18n` (overall summary), `questline_id` (FK, nullable), `giver_entity_type` (ENUM `RelationshipEntityType`, nullable), `giver_entity_id` (INT, nullable), `min_level` (INT, nullable), `is_repeatable` (bool), `cooldown_hours_on_completion` (INT, if repeatable), `rewards_json` (JSONB: default rewards for quest completion - XP, items, gold, relationship changes, world state flags), `properties_json` (e.g., quest type tag like "slay", "fetch", "escort"; difficulty tag), `ai_metadata_json`.
    - **`QuestStep` Model**: `id`, `guild_id`, `quest_id` (FK to `GeneratedQuest`), `step_order` (INT), `title_i18n` (optional, for display), `description_i18n` (detailed instructions for this step), `required_mechanics_json` (JSONB: defines what game event/action completes this step, e.g., `{"event_type": "ITEM_ACQUIRED", "details_subset": {"item_static_id": "macguffin", "quantity": 1}}` or `{"event_type": "NPC_INTERACTED", "details_subset": {"npc_static_id": "oracle", "dialogue_choice_id": "secret_revealed"}}`), `abstract_goal_json` (JSONB, optional: for goals requiring complex evaluation, e.g., `{"enabled": true, "description_i18n": {"en": "Impress the Baron."}, "evaluation_method": "llm_based" or "rule_based", "rule_config_key": "quest_goals:impress_baron"}`), `consequences_json` (JSONB: specific outcomes for completing *this step* - can be similar structure to `GeneratedQuest.rewards_json`), `next_step_order` (INT, nullable, for branching if current step has multiple outcomes), `properties_json` (e.g., hints, is_hidden_step).
    - **`PlayerQuestProgress` Model**: `id`, `guild_id`, `player_id` (FK, nullable), `party_id` (FK, nullable, ensure one of player/party is set), `quest_id` (FK to `GeneratedQuest`), `current_step_id` (FK to `QuestStep`, nullable if quest not started/completed), `status` (ENUM `QuestStatus`: `NOT_STARTED`, `STARTED`, `IN_PROGRESS`, `COMPLETED`, `FAILED`, `ABANDONED`), `progress_data_json` (JSONB: for tracking step-specific counters, e.g., `{"goblins_slain": 3}`), `accepted_at` (DATETIME), `completed_at` (DATETIME, nullable), `failed_at` (DATETIME, nullable). Add `UniqueConstraint` for (`guild_id`, `player_id`, `quest_id`) and (`guild_id`, `party_id`, `quest_id`) if a quest can only be active once per player/party.
    - All models include `TimestampMixin` for `created_at`, `updated_at`.
Result: Fully defined database schema for a comprehensive quest system, supporting complex multi-step quests, branching, varied objectives, and detailed progress tracking for both players and parties.

Task 40: 🧬 9.2 AI Quest Generation (According to Rules, Multilang, Per Guild).
Description: **A to Z Implementation**: Enable AI to generate complete, multi-step quests with objectives, mechanics, and consequences, tailored to guild-specific rules, lore, and existing world state.
    - **Trigger**: Part of larger content generation (Task 2.6) or specific Master command. Context can include target player level, location, desired quest type/theme, linked entities (e.g., quest giver NPC).
    - **Prompt Preparation (Task 2.2)**:
        - Construct a detailed prompt requesting a `GeneratedQuest` object, including a list of `QuestStep` objects.
        - Provide `RuleConfig` guidelines:
            - `ai:generation:quest:structure_templates:<quest_type>` (e.g., typical number of steps for "fetch" vs "investigation" quests).
            - `ai:generation:quest:mechanic_options` (list of valid `required_mechanics_json.event_type` and typical `details_subset` structures AI can use).
            - `ai:generation:quest:reward_guidelines:<difficulty>` (typical XP/gold/item rewards for quest difficulty).
            - `ai:generation:quest:theme_elements:<theme_name>` (keywords, typical NPCs/items for a given theme).
        - Include current world state snippets, relevant NPC/faction info from context to ensure generated quest fits the world.
        - Request i18n for all text fields.
    - **AI Call & Parsing (Task 2.3, 2.6)**:
        - Invoke LLM.
        - Parse response into `ParsedQuestData` (which includes a list of `ParsedQuestStepData`). Perform thorough validation of structure, mechanics, and consistency (e.g., `next_step_order` forms valid chains).
    - **Saving (Task 2.6 `save_approved_generation` extension)**:
        - After Master approval (if moderation is enabled):
            - Create `GeneratedQuest` record.
            - For each `ParsedQuestStepData`, create corresponding `QuestStep` records, linked to the parent `GeneratedQuest`.
            - Ensure `guild_id` propagation and transactional integrity.
    - **Complexity Handling**: AI should be guided to generate quests of varying complexity, potentially including branching steps (multiple `next_step_order` options based on different outcomes of a step, though model might need `QuestStep.outcome_conditions_json` for this).
    - **Logging**: Log `QUEST_BATCH_GENERATED_AI` event.
Result: A system capable of AI-generating diverse and structurally sound quests that are thematically consistent with the guild's world and adhere to defined gameplay mechanics and reward structures.

Task 41: 📚 9.3 Quest Tracking and Completion System (Guild-Scoped).
Description: **A to Z Implementation**: Develop a comprehensive system for tracking player/party progress through quests, evaluating step completion based on game events, and applying all defined consequences.
    - **API `handle_player_event_for_quest(session, guild_id: int, event_log_entry: StoryLog, player_id: Optional[int] = None, party_id: Optional[int] = None)`**:
        - Called by Action Processor (Task 6.11) after every significant player/party action or by other systems posting to `StoryLog`.
        - Determine all relevant `PlayerQuestProgress` entries for the involved player(s)/party in status `STARTED` or `IN_PROGRESS`.
    - **Mechanic Matching (`_check_mechanic_match`)**:
        - For each active quest and its `current_step`:
            - Compare `event_log_entry.event_type` and `event_log_entry.details_json` against `current_step.required_mechanics_json`.
            - Use `RuleConfig` (`quest_rules:mechanic_matching:<EVENT_TYPE_NAME>`) to define how `details_json` fields map to `details_subset` fields and what comparison types to use (exact match, contains, value range).
    - **Abstract Goal Evaluation (`_evaluate_abstract_goal`)**:
        - If `current_step.abstract_goal_json.enabled` is true:
            - If `evaluation_method` is `"llm_based"`: Prepare prompt (Task 2.2) with goal description, recent relevant `StoryLog` entries for player/party, current world state. Call LLM (Task 7.2) to return a boolean assessment.
            - If `evaluation_method` is `"rule_based"`: Load rules from `RuleConfig` (key from `abstract_goal_json.rule_config_key`). Evaluate these rules against current game state (player stats, inventory, world flags, aggregated past events).
    - **Step Completion & Consequence Application (`_apply_quest_consequences`)**:
        - If mechanic matched AND (no abstract goal OR abstract goal evaluated to true):
            - Apply consequences defined in `current_step.consequences_json` (XP, items, relationship changes, world state changes) by calling respective system APIs (Tasks 13.2, related to 10.1/10.3, 8.4, update `RuleConfig`).
            - Log `QUEST_STEP_COMPLETED` event.
    - **Advancing Quest (`_advance_quest_progress`)**:
        - If step completed, determine `next_step_order` from `current_step`.
        - Find the next `QuestStep` in `GeneratedQuest.steps`.
        - If next step exists: update `PlayerQuestProgress.current_step_id`. Log `SYSTEM_EVENT` for "new step started". Provide feedback.
        - If no next step (or `next_step_order` is a terminal indicator):
            - Mark `PlayerQuestProgress.status` as `COMPLETED`. Set `completed_at`.
            - Apply overall quest rewards from `GeneratedQuest.rewards_json` (using `_apply_quest_consequences`).
            - Log `QUEST_COMPLETED` event. Provide feedback.
            - Trigger any subsequent quest in a `Questline` if defined.
    - **Handling Failure/Abandonment**:
        - Implement logic for `PlayerQuestProgress.status = FAILED` (e.g., time limit expired, key NPC died, critical objective failed based on an event). Apply consequences from `GeneratedQuest.properties_json.failure_consequences_json`.
        - Implement player command `/quest abandon <quest_id>` which sets status to `ABANDONED`.
    - **Error Handling & Logging**: Robust error handling and detailed logging throughout.
Result: A comprehensive quest system that dynamically tracks and updates player progress based on diverse game events, evaluates complex objectives, and applies rich, interconnected consequences.


Task Block: Phase 10: Economy, Items, and Trade
Task 42: 💰 10.1 Data Structure (Guild-Scoped, i18n).
Description: Define models for `Item`, `ItemProperty` (if distinct from `Item.properties_json`), and `InventoryItem`. Establish how economy rules (base prices, price adjustments, item availability) are stored in `RuleConfig`.
    - **`Item` Model (0.2/7)**: `id`, `guild_id` (nullable for global/template items), `static_id` (unique per guild or globally if `guild_id` is null), `name_i18n`, `description_i18n`, `item_type_i18n` (e.g., "Weapon", "Potion", "Armor", "Junk"), `item_category_i18n` (e.g., "Sword", "Healing Potion", "Heavy Armor"), `base_value` (INT, currency implicit or in properties), `is_stackable` (BOOLEAN), `slot_type` (TEXT ENUM for equippable items: "MAIN_HAND", "HEAD", "CONSUMABLE"), `properties_json` (JSONB: detailed stats, effects on use/equip, skill requirements, crafting components, visual appearance key, rarity tag).
    - **`InventoryItem` Model (0.2/7)**: `id`, `guild_id`, `owner_entity_id`, `owner_entity_type` (ENUM `RelationshipEntityType`), `item_id` (FK to `Item`), `quantity` (INT), `equipped_status` (TEXT ENUM for `slot_type` or generic "EQUIPPED", nullable), `instance_specific_properties_json` (JSONB: for unique item instances, e.g., durability, specific enchantments, soulbound status).
    - **`RuleConfig` for Economy**:
        - `economy:base_item_values:<item_category_or_type_key>`: Default prices.
        - `economy:price_modifiers:<modifier_type>`: Rules for price adjustments (skill, relationship, location tax, demand/supply simulation if advanced).
        - `economy:npc_inventory_templates:<npc_role_key>`: Defines typical trader inventories.
        - `economy:regional_item_availability:<location_tag>`: Controls what items are commonly found/sold in areas.
        - `economy:currency_name_i18n`: `{"en": "Gold", "ru": "Золото"}`.
Result: Robust data structures for items and inventory, and a clear definition of `RuleConfig` keys for governing all aspects of the game economy.

Task 43: 💰 10.2 AI Economic Entity Generation (Per Guild).
Description: **A to Z Implementation**: Enable AI to generate balanced and thematically appropriate items and NPC traders for a guild, based on `RuleConfig` and world context.
    - **Trigger**: Part of larger content generation (Task 2.6) or specific Master command. Context: desired item types/rarity, trader roles, location for trader.
    - **Prompt Preparation (Task 2.2)**:
        - For Items: Request `Item` data including `static_id`, `name_i18n`, `description_i18n`, `item_type_i18n`, `properties_json` (stats, effects), `base_value`. Prompt should use `RuleConfig` for item themes, typical stats for level/rarity (`ai:generation:item:balance_rules:<item_type>`), and desired i18n.
        - For NPC Traders: Request `GeneratedNpc` data (`ParsedNpcTraderData`) including `name_i18n`, `role_i18n` (e.g., "Blacksmith", "Alchemist"), `inventory_template_key` (from `RuleConfig economy:npc_inventory_templates`) or a list of `GeneratedInventoryItemEntry` (item `static_id`s and quantities for their initial stock), and potentially some personality/dialogue hints.
    - **AI Call & Parsing (Task 2.3, 2.6)**: Invoke LLM, parse into `ParsedItemData` and `ParsedNpcTraderData`. Validate against schemas and economic rules (e.g., generated `base_value` within acceptable range for item type/properties).
    - **Saving (Task 2.6 `save_approved_generation` extension)**:
        - After approval:
            - Create `Item` records.
            - Create `GeneratedNpc` records for traders, storing `role_i18n` and `inventory_template_key` in `properties_json`.
            - For each trader, if `generated_inventory_items` were provided by AI:
                - For each `GeneratedInventoryItemEntry`: Resolve `item_static_id` to an `Item.id` (must exist or be part of same generation batch).
                - Create `InventoryItem` records linked to the trader NPC, with random quantity within `quantity_min`/`quantity_max` if `chance_to_appear` met.
    - **Balance & Consistency**: AI should be guided by `RuleConfig` to generate items and trader inventories that are balanced for the game's economy and appropriate for the world's lore and specific locations.
Result: A system that uses AI to populate the game world with unique items and specialized NPC traders with appropriate stock, all configurable per guild.

Task 44: 💰 10.3 Trade System (Guild-Scoped).
Description: **A to Z Implementation**: Develop a comprehensive system for managing trade interactions between players and NPCs (or players, if p2p trade is supported).
    - **API**: `handle_trade_action(session, guild_id: int, player_id: int, target_npc_id: Optional[int], action_type: str, item_identifier: Optional[Union[int, str]], inventory_item_id: Optional[int], quantity: Optional[int]) -> TradeActionResult`.
        - `action_type`: "view_inventory", "buy", "sell", "start_trade_session", "end_trade_session".
        - `item_identifier`: `Item.static_id` or `Item.id` for buying.
        - `inventory_item_id`: `InventoryItem.id` from player's inventory for selling.
    - **Trade Session Management (Optional but recommended for UI)**:
        - `start_trade_session`: Locks items in NPC inventory (if dynamic), sets player status.
        - `end_trade_session`: Releases locks, clears temporary trade data.
    - **View Inventory**: Display NPC's (or player's) inventory with calculated buy/sell prices for the active player.
    - **Price Calculation (`_calculate_item_price`)**:
        - Start with `Item.base_value`.
        - Apply modifiers from `RuleConfig` (`economy:price_modifiers:*`):
            - Player's trade skill level.
            - Relationship value between player and trader (Task 37).
            - Faction standing influence.
            - Location-specific taxes or tariffs.
            - Global economic state (supply/demand simulation, if implemented).
        - Differentiate between player buying price (typically higher) and player selling price (typically lower).
    - **Buy/Sell Logic**:
        - **Validation**: Check item availability, player's gold (for buying), player's item quantity (for selling), NPC's gold (if limited), carrying capacity.
        - **Transactional Update**: Atomically:
            - Adjust Player/NPC gold.
            - Transfer `InventoryItem` records (create new, update quantity, or delete if quantity becomes zero). Handle stackable vs. non-stackable items.
        - If transaction fails (e.g., item bought by another party member simultaneously if not locked by session), ensure full rollback.
    - **Relationship Impact**: Call Relationship System (Task 8.4) to update player-trader relationship based on trade volume/fairness (defined in `RuleConfig`).
    - **Logging & Feedback**: Log `TRADE_ITEM_BOUGHT`/`SOLD` events to `StoryLog`. Provide clear, localized feedback (success, failure reasons, prices) via `TradeActionResult`.
    - **Error Handling**: Robustly handle all edge cases (item not found, insufficient funds/items, NPC not a trader, etc.).
Result: A complete and dynamic trade system with rule-based pricing, inventory management, and integration with social and logging systems.


Task Block: Phase 14: Global Entities and Dynamic World
Task 45: 🌌 14.1 Global Entity Models (Guild-Scoped, i18n).
Description: Define data models for entities that move and act in the game world independently of direct player control, such as caravans, patrols, wandering monsters, or dynamic global events.
    - **`GlobalNpc` Model (0.2/7)**: Represents an individual NPC that operates globally.
        - Fields: `id`, `guild_id`, `static_id` (unique within guild), `name_i18n`, `description_i18n`, `npc_template_id` (FK to `GeneratedNpc` for base stats/abilities, optional), `current_location_id` (FK, nullable), `mobile_group_id` (FK to `MobileGroup`, nullable, if part of a group), `properties_json` (current HP/resources if different from template, current goal (e.g., "patrol_route_A", "travel_to_city_B"), behavior tags, AI state), `ai_metadata_json`.
    - **`MobileGroup` Model (0.2/7)**: Represents a group of GlobalNpcs or other entities moving together.
        - Fields: `id`, `guild_id`, `static_id`, `name_i18n`, `description_i18n`, `current_location_id` (FK, nullable), `leader_global_npc_id` (FK to `GlobalNpc`, nullable), `members_definition_json` (JSONB: list of `{"global_npc_static_id": str, "role_in_group_i18n": json}` or `{"npc_template_id": int, "count": int, "role_in_group_i18n": json}` for dynamically spawned members), `behavior_type_i18n` (e.g., "merchant_caravan", "bandit_patrol", "refugee_column"), `route_json` (JSONB: list of `location_id`s or `static_id`s for pathing, or target destination), `properties_json` (current group goal, formation, speed, AI state, shared resources).
    - **`GlobalEvent` Model (0.2/7)**: Represents a dynamic event occurring in the world, potentially affecting locations or entities.
        - Fields: `id`, `guild_id`, `event_type_static_id` (links to `RuleConfig` for event mechanics), `name_i18n`, `description_i18n`, `status` (ENUM: `SCHEDULED`, `ACTIVE`, `CONCLUDED`, `CANCELLED`), `start_time_epoch` (INT, nullable), `duration_seconds` (INT, nullable), `target_location_ids_json` (JSONB: list of affected `Location.id`s, nullable), `affected_faction_ids_json` (JSONB: list of `GeneratedFaction.id`s, nullable), `trigger_conditions_json` (JSONB: conditions for event to start), `effects_on_start_json` (JSONB: immediate changes to WorldState, entity spawns), `ongoing_effects_rules_key` (TEXT: key in `RuleConfig` defining continuous impacts), `resolution_conditions_json` (JSONB: conditions for event to conclude), `effects_on_resolution_json` (JSONB: final changes).
Result: Comprehensive data models for various types of global entities and events, enabling a dynamic and evolving game world.

Task 46: 🧬 14.2 Global Entity Management (Per-Guild Iteration).
Description: **A to Z Implementation**: Develop a module that simulates the behavior, movement, and interactions of all `GlobalNpc` and `MobileGroup` entities for each guild, and manages the lifecycle of `GlobalEvent`s.
    - **Async Worker(s)**: One or more asynchronous workers that periodically iterate through all active guilds.
    - **For each guild_id**:
        - **Load Data**: Load all active `GlobalNpc`s, `MobileGroup`s, and `GlobalEvent`s for the guild. Load relevant `RuleConfig` entries (`rules:global_entity:movement`, `rules:global_entity:interaction_detection_dc`, `rules:global_entity:reaction_matrix:<entity_type>`).
        - **Global Event Lifecycle**:
            - Check `GlobalEvent.trigger_conditions_json` against current game state. If met and event is `SCHEDULED`, change status to `ACTIVE` and apply `effects_on_start_json`. Log `GLOBAL_EVENT_STARTED`.
            - For `ACTIVE` events, apply `ongoing_effects_rules_key` (e.g., spawn temporary entities, modify location properties, affect player actions in area).
            - Check `GlobalEvent.resolution_conditions_json`. If met, change status to `CONCLUDED`, apply `effects_on_resolution_json`. Log `GLOBAL_EVENT_CONCLUDED`.
        - **Global NPC & Mobile Group Simulation**:
            - **Goal Update**: For each GE/MG, determine current goal based on `properties_json.goal`, schedule (e.g., from `RuleConfig` `ge_schedules:<static_id>`), or dynamic events.
            - **Movement**:
                - If goal involves travel, determine next `Location.id` in `route_json` or pathfind towards destination.
                - Simulate movement time based on distance, terrain (from `Location.type`), GE/MG speed (from `properties_json`).
                - Update `current_location_id`. Log `GLOBAL_ENTITY_MOVED`.
            - **Interactions**:
                - In new location, perform detection checks (Check Resolver Task 6.3.2) against players, other GEs/MGs, and significant static entities based on `RuleConfig` (detection range, DC modifiers for stealth/perception).
                - If detection occurs, log `GLOBAL_ENTITY_DETECTED_ENTITY`.
                - **Reaction**: Based on `RuleConfig` (`rules:global_entity:reaction_matrix:<actor_type>:<target_type>`), relationships (Task 37), and GE/MG current goal/state, choose a reaction:
                    - Initiate combat (call Combat Cycle Task 5.4 `start_combat`).
                    - Attempt to initiate dialogue (create a placeholder interaction or call Dialogue System Task 11.2 if GE can "talk" and player is present).
                    - Trigger a quest (call Quest System Task 9.3 `handle_player_event_for_quest` with a custom event).
                    - Ignore, flee, or continue on current path.
                    - Log `GLOBAL_ENTITY_ACTION`.
        - **State Persistence**: All changes to GE/MG/GlobalEvent states must be saved to DB transactionally per guild iteration.
    - **Scalability**: Ensure worker(s) can handle many guilds without significant slowdown, possibly by distributing guild processing.
Result: A dynamic world simulation where global entities and events actively shape the game environment and create emergent interaction opportunities for players.


Task Block: Phase 15: Management and Monitoring Tools
Task 47: 🛠️ 15.1 Master Command System.
Description: **A to Z Implementation**: Implement a comprehensive suite of Discord slash commands for Game Masters to manage all aspects of gameplay, data, and configuration within their specific guild. All commands must be guild-scoped, support i18n for arguments and output, and provide clear feedback.
    - **CRUD Operations**: For **every significant database model** (Player, Party, Location, GeneratedNpc, GlobalNpc, MobileGroup, Item, InventoryItem, Ability, StatusEffectDefinition, ActiveStatusEffect, GeneratedFaction, Relationship, GeneratedQuest, QuestStep, Questline, PlayerQuestProgress, PendingGeneration, PendingConflict, CombatEncounter, StoryLog (view/list only), CraftingRecipe, Skill, PlayerNpcMemory, PartyNpcMemory, GlobalEvent), implement commands for:
        - `create <parameters...>`: Create new entity. Parameters should accept JSON for complex fields.
        - `view <id_or_static_id>`: View details of an entity.
        - `list [filters...] [page] [limit]`: List entities with pagination and relevant filters.
        - `update <id_or_static_id> <field_to_update> <new_value_json_or_simple>`: Update a specific field of an entity.
        - `delete <id_or_static_id>`: Delete an entity (with confirmation and handling of dependencies).
    - **`RuleConfig` Management**:
        - `/master_ruleconfig get <key>`
        - `/master_ruleconfig set <key> <value_json>`
        - `/master_ruleconfig list [prefix] [page] [limit]`
        - `/master_ruleconfig delete <key>`
        - `/master_ruleconfig export_all`: Export all rules for the guild as a JSON file.
        - `/master_ruleconfig import_all <json_file_attachment>`: Import rules, with options to overwrite or merge.
    - **Gameplay Management**:
        - `/master_action trigger_event <event_type_name> <details_json> [location_id] [player_id]`: Manually trigger a game event.
        - `/master_action modify_player_stat <player_id> <stat_name> <new_value_or_delta>`
        - `/master_action award_item <player_id> <item_static_id> [quantity]`
        - `/master_action teleport_entity <entity_id> <entity_type> <target_location_id_or_static_id>`
        - `/master_combat start <npc_static_ids_json_list> [player_ids_json_list] [location_id]`
        - `/master_combat end <combat_encounter_id> [outcome_status]`
        - `/master_quest assign <player_id_or_party_id> <quest_static_id>`
        - `/master_quest advance_step <player_quest_progress_id> [step_order_or_id]`
        - `/master_quest complete <player_quest_progress_id>`
    - **Conflict Resolution**: `/master_conflict resolve <pending_conflict_id> <outcome_status_enum> [notes]`: Resolves a pending conflict and signals the Turn Processor (Task 6.11) to potentially resume.
    - **AI Management**: Commands for triggering AI generation (Task 2.6, 24), managing `PendingGeneration` queue (approve, reject, edit - see Task 2.6 for details).
    - **Permissions**: All master commands must be restricted to users with appropriate Discord permissions (e.g., Administrator) or a defined Master role within the guild.
    - **Localization**: All command descriptions, parameter names, choices, and output messages must be localized using `localization_utils` and `RuleConfig` for text templates.
    - **Error Handling**: Robust error handling for invalid parameters, non-existent entities, failed operations, with clear, localized feedback.
Result: A complete and powerful suite of Game Master commands providing full control over all aspects of the game world, data, and ongoing gameplay for each guild.

Task 48: 🛠️ 15.2 Balance and Testing Tools (Per Guild).
Description: **A to Z Implementation**: Develop a suite of Game Master commands and underlying APIs for simulating game mechanics and analyzing generated content to aid in balancing and testing, all operating within the guild's specific context and rules.
    - **Simulation APIs & Commands**:
        - **Check Simulation (`/master_simulate check`)**:
            - Parameters: `actor_id`, `actor_type`, `check_type`, `target_id` (opt), `target_type` (opt), `difficulty_dc` (opt), `context_json` (opt).
            - Calls Check Resolver (Task 6.3.2) using current stats of entities and guild's `RuleConfig`.
            - Output: Detailed breakdown of the check (roll, modifiers with sources, final result, outcome), localized.
        - **Combat Action Simulation (`/master_simulate combat_action`)**:
            - Parameters: `combat_encounter_id` (or setup for mock combat: `actor_data_json`, `target_data_json_list`), `actor_id`, `actor_type`, `action_data_json` (describing attack/ability), `dry_run` (bool, if true, no DB changes).
            - Calls Combat Engine (Task 5.2).
            - Output: Detailed `CombatActionResult` (damage, effects, checks), localized. If not dry_run, indicates that state *was* changed.
        - **Conflict Simulation (`/master_simulate conflict_detection`)**:
            - Parameters: `list_of_actions_json` (each action: actor_id, actor_type, parsed_action_intent_and_entities).
            - Uses `conflict_simulation_system.simulate_conflict_detection` with current `RuleConfig`.
            - Output: List of detected potential conflicts with reasons, localized.
        - **Ability Outcome Simulation (`/master_simulate ability_outcome`)**:
             - Parameters: `actor_id`, `actor_type`, `ability_id_or_static_id`, `target_ids_json_list`, `context_json`.
             - Calls Ability System (Task 3.3) in a dry-run mode (if possible, or clearly state it's a live test affecting ephemeral mock entities).
             - Output: Detailed `AbilityOutcomeDetails`, localized.
    - **AI Generation Analyzers (`/master_analyze ai_generation`)**:
        - Parameters: `entity_type_to_generate` (npc, item, quest, etc.), `target_count`, `generation_context_json` (opt), `use_real_ai` (bool).
        - Triggers AI generation (mock or real via Task 2.6 logic but doesn't save to `PendingGeneration` unless specified).
        - **Analysis Logic (`ai_analysis_system.py`)**:
            - **Content Quality**: Check i18n completeness, text length/style against `RuleConfig` (`ai:analysis:text_quality`), placeholder detection.
            - **Balance**:
                - Items: Compare `base_value` and `properties_json` stats against `RuleConfig` (`ai:analysis:item_balance:<item_type>`).
                - NPCs: Compare stats (HP, attack) against level and `RuleConfig` (`ai:analysis:npc_balance:<npc_type_or_role>`).
                - Quests: Evaluate reward appropriateness (XP, items) for quest level/steps using `RuleConfig` (`ai:analysis:quest_rewards`).
            - **Lore Consistency**: Check generated names/descriptions against guild lore keywords (from `RuleConfig` `world_lore:keywords_allowed/forbidden`).
            - **Structural Integrity**: For complex objects like quests, check for valid step chaining, defined mechanics.
        - Output: Detailed report for each generated entity: preview, issues found (errors, warnings, suggestions), balance scores, localized.
    - **All tools use current `guild_id` data and `RuleConfig`. Results are localized.**
Result: A comprehensive suite of simulation and analysis tools enabling Game Masters to effectively test mechanics, balance gameplay, and verify the quality of AI-generated content for their guild.

Task 49: 🛠️ 15.3 Monitoring Tools (Guild-Scoped).
Description: **A to Z Implementation**: Provide Game Masters with a comprehensive set of Discord commands to view various aspects of the game state and history within their guild, with data filtered by `guild_id` and formatted in the Master's language.
    - **Viewing Commands (all with pagination and relevant filters where applicable)**:
        - **Event Log (`/master_monitor log ...`)**:
            - `view <log_id>`: Detailed view of a single `StoryLog` entry.
            - `list [event_type] [entity_id_filter_json] [page] [limit]`: List `StoryLog` entries. `entity_id_filter_json` could be `{"player_id": 123}`.
        - **WorldState (`/master_monitor worldstate ...`)**:
            - `get <key>`: View a specific `RuleConfig` entry used as a world state flag.
            - `list [prefix] [page] [limit]`: List `RuleConfig` entries (e.g., those starting with `worldstate:`).
        - **Map & Locations (`/master_monitor map ...`)**:
            - `view_location <location_id_or_static_id>`: Details of a `Location`.
            - `list_locations [page] [limit]`: List all `Location`s.
            - `who_is_at <location_id_or_static_id>`: List players, parties, NPCs, GEs at a location.
        - **Entities (`/master_monitor entities ...`)**: Subcommands for each major entity type (Player, Party, GeneratedNpc, GlobalNpc, MobileGroup, Item (definitions), Faction, Quest (definitions), CombatEncounter (active/recent)):
            - `view <id_or_static_id>`: View details of a specific entity.
            - `list [filters...] [page] [limit]`: List entities of that type.
        - **Game Statistics (`/master_monitor statistics ...`)**:
            - `guild_overview`: Total players, NPCs, locations, active quests, current turn number, etc.
            - `player_activity [player_id_or_name]`: Last active time, turns played, quests completed (requires aggregation from `StoryLog` or dedicated stats tables).
            - `economy_summary`: Total gold in circulation, most common items (requires aggregation).
            - This section requires defining what statistics are valuable and how they are collected/calculated. May involve creating new tables or complex queries on `StoryLog`.
    - **Output Formatting**: All command outputs use Report Formatting System (Task 7.3/54) for clear, localized presentation, often in `discord.Embed`s.
    - **Data Access**: Commands use CRUD utilities (Task 0.3) to fetch data, ensuring `guild_id` scoping.
Result: A comprehensive set of monitoring tools allowing Game Masters to easily inspect and understand the current state and historical activity of their game world.


Task Block: Phase 11: Dynamic Dialogue and NPC Memory
Task 50: 🧠 11.1 Dialogue Generation Module (LLM, Multy-i18n, According to Rules).
Description: **A to Z Implementation**: Develop a module to prepare prompts and call an LLM for generating dynamic, contextually appropriate NPC dialogue lines in multiple languages, governed by `RuleConfig`.
    - **API**: `generate_npc_dialogue(session, guild_id: int, npc_id: int, player_id: int, current_dialogue_history: List[Dict[str,str]], player_input_text: str, language_code: str, additional_context: Optional[Dict[str, Any]] = None) -> str` (returns generated NPC line).
        - `current_dialogue_history`: List of `{"speaker": "player/npc_name", "line": "text"}`.
        - `additional_context`: e.g., active quest step involving this NPC, recent relevant world events.
    - **Prompt Engineering (using AI Prompt Prep Module - Task 2.2)**:
        - Construct a detailed prompt including:
            - **NPC Profile**: Name, personality traits (from `GeneratedNpc.properties_json.personality_tags`), role, faction, current emotional state (if tracked).
            - **Player Profile**: Name, known reputation/relationship with NPC (Task 37).
            - **Dialogue History**: Recent lines to maintain conversational context.
            - **Current Game Context**: Location, time of day, active quests involving NPC/player, relevant `WorldState` flags.
            - **NPC Memory**: Key interaction summaries from `PlayerNpcMemory` (Task 11.3) regarding this player.
            - **Dialogue Rules (`RuleConfig`)**:
                - `dialogue:npc_personality:<tag>:response_style_guidelines_i18n` (e.g., "formal", "gruff", "talkative").
                - `dialogue:topic_knowledge:<npc_static_id_or_role>:<topic_keyword>` (what this NPC knows).
                - `dialogue:forbidden_topics_or_phrases`.
            - **Player's Input**: `player_input_text`.
            - **Instruction**: "Generate the NPC's next dialogue line in `{language_code}` that is consistent with all the above."
    - **LLM Interaction (via AI Orchestrator - Task 2.6 extension or direct call)**:
        - Call the configured LLM API with the prepared prompt.
        - Handle API errors, timeouts, content filters.
    - **Output Processing**: Sanitize LLM output. Ensure it's just the dialogue line.
    - **i18n**: Generate dialogue in the specified `language_code`. Use localized entity names (from DB) when constructing prompt context for the LLM.
Result: A robust system for generating dynamic and contextually rich NPC dialogue using LLMs, tailored by NPC personality, player relationship, and game state, in multiple languages.

Task 51: 🧠 11.2 Dialogue Context and Status (Guild-Scoped).
Description: **A to Z Implementation**: Implement the full logic for managing the state and flow of a dialogue session between a player (or party) and an NPC.
    - **Dialogue State Storage**:
        - In-memory store (e.g., a dictionary `active_dialogues` keyed by `(guild_id, player_id)` or `(guild_id, party_id)`) holding:
            - `npc_id`
            - `dialogue_history: List[Dict[str, str]]` (speaker, line)
            - `current_dialogue_options_presented_ids: List[str]` (if using structured options)
            - `dialogue_state_flags_json: Dict[str, Any]` (e.g., "topic_discussed_A", "npc_mood_shifted")
        - Alternatively, consider a temporary DB table for `ActiveDialogueSession` if persistence across bot restarts is critical for long dialogues, though this adds complexity.
    - **API `start_dialogue(session, guild_id: int, player_id: int, target_npc_id: int) -> StartDialogueResult`**:
        - Called by Action Processor (Task 6.11) or a direct command.
        - Validate: NPC exists, is interactive, player not in combat, etc.
        - Set `Player.current_status` to `PlayerStatus.DIALOGUE`.
        - Initialize entry in `active_dialogues`.
        - Generate NPC's opening line using Dialogue Generation Module (Task 11.1), potentially based on context (time of day, player approach, NPC current action).
        - Return `StartDialogueResult` (success, opening line, initial options if any).
        - Log `DIALOGUE_START` event.
    - **API `handle_dialogue_input(session, guild_id: int, player_id: int, player_input_text: str, parsed_nlu_action: Optional[ParsedAction]) -> DialogueTurnResult`**:
        - Called by Action Processor (Task 6.11 via Task 53) when player in `DIALOGUE` status sends a message.
        - Add player's line to `dialogue_history`.
        - **Intent Processing**:
            - If `parsed_nlu_action` indicates a meta-intent like "end_dialogue", call `end_dialogue`.
            - If `parsed_nlu_action` indicates a choice from structured options, validate choice ID.
            - Otherwise, treat `player_input_text` as conversational.
        - Generate NPC response using Dialogue Generation Module (Task 11.1), passing full history and context.
        - Add NPC's line to `dialogue_history`.
        - **Apply Dialogue Effects**: Based on `RuleConfig` (`dialogue:effects:<npc_static_id_or_role>:<dialogue_node_or_keyword_trigger>`), NPC response, or player choice, trigger consequences:
            - Update `dialogue_state_flags_json`.
            - Call Quest System (Task 9.3), Relationship System (Task 8.4).
            - Grant items, information (update Player memory or `WorldState`).
        - Determine next set of dialogue options (if using structured options) based on current state and rules.
        - Return `DialogueTurnResult` (NPC response, new options, any game state changes like quest updates).
        - Log `DIALOGUE_LINE` event for both player and NPC lines.
    - **API `end_dialogue(session, guild_id: int, player_id: int) -> EndDialogueResult`**:
        - Clear player's entry from `active_dialogues`.
        - Revert `Player.current_status` (e.g., to `EXPLORING`).
        - Log `DIALOGUE_END` event.
        - Return `EndDialogueResult` (success, concluding message if any).
    - **Party Dialogues**: Extend logic to handle party dialogues if a party initiates. `RuleConfig` defines who speaks for party or if members can interject. `active_dialogues` key might be `party_id`.
Result: A comprehensive dialogue management system that handles session state, player input, NPC response generation, application of dialogue-driven game effects, and supports both free-form and potentially structured dialogue interactions.

Task 52: 🧠 11.3 NPC Memory Management (Persistent, Per Guild).
Description: **A to Z Implementation**: Implement a persistent memory system for NPCs to recall significant past interactions and information regarding specific players or parties, influencing future interactions.
    - **Models (Task 2.1)**:
        - `PlayerNpcMemory`: `id`, `guild_id`, `player_id` (FK), `npc_id` (FK to `GeneratedNpc`), `event_type` (ENUM `EventType` or specific memory type), `timestamp`, `importance_score` (INT, 0-100), `summary_i18n` (JSONB, brief text summary of the memory), `details_json` (JSONB, full context of the remembered event).
        - `PartyNpcMemory`: Similar, with `party_id` (FK).
    - **API `add_to_npc_memory(session, guild_id: int, npc_id: int, event_log_entry: StoryLog, summary_i18n: Dict[str, str], importance_score: int, relevant_player_id: Optional[int] = None, relevant_party_id: Optional[int] = None)`**:
        - Called by other modules (Dialogue, Quest, Combat, Trade, Action Processor) upon significant events that an NPC should remember about a player/party.
        - `event_log_entry.details_json` becomes `details_json` for the memory.
        - Create `PlayerNpcMemory` or `PartyNpcMemory` record.
        - **Memory Pruning/Summarization (Advanced)**: `RuleConfig` (`npc_memory:max_entries_per_pair`, `npc_memory:summarization_trigger_threshold`) could define when to prune old/low-importance memories or trigger an LLM call to summarize multiple related memories into one.
    - **API `get_npc_memory_for_context(session, guild_id: int, npc_id: int, player_id: Optional[int] = None, party_id: Optional[int] = None, query_keywords: Optional[List[str]] = None, limit: int = 5) -> List[PlayerNpcMemory | PartyNpcMemory]`**:
        - Retrieves relevant memories for an NPC about a player/party.
        - Filter by `importance_score >= RuleConfig(npc_memory:min_importance_for_recall)`.
        - If `query_keywords`, search `summary_i18n` or `details_json`.
        - Order by `timestamp` (desc) and `importance_score` (desc).
        - Used by Dialogue Generation (Task 11.1) and NPC Combat Strategy (Task 5.3) to provide context.
    - **Integration**: Ensure all key game systems call `add_to_npc_memory` appropriately:
        - Dialogue: Memorable choices, information revealed, promises made/broken.
        - Quests: Player accepting/completing/failing quests given by NPC.
        - Combat: Player defeating NPC, sparing NPC, critical hits received from player.
        - Relationships: Significant relationship milestones.
        - Trade: Very large or unfair trades.
Result: A persistent NPC memory system allowing NPCs to recall past interactions, leading to more believable, evolving NPC behavior and personalized player experiences.

Task 53: 🧠 11.4 NLU and Intent Recognition in Dialogue (Guild-Scoped).
Description: Ensure NLU (Task 6.10) correctly processes player input during dialogue mode. If `Player.current_status == PlayerStatus.DIALOGUE`, NLU should still parse the input for intents and entities, but instead of queuing an action in `Player.collected_actions_json`, the `ParsedAction` (or its components: intent, entities, original text) is passed directly to the Dialogue Management Module's `handle_dialogue_input` API (Task 51). This allows dialogue system to react to specific player intents within conversation (e.g., player asks "what quests do you have?", NLU recognizes "query_quests" intent).
Result: NLU effectively supports dialogue system by providing structured understanding of player utterances within a conversation.

Task Block: Feedback Formatting System
Task 54: ⚙️ 6.7.1 Log and Feedback Formatting System (Full, Multy-i18n, Guild-Scoped).
Description: **A to Z Implementation**: Develop a comprehensive module that transforms structured event data (from `StoryLog`) into readable, localized reports for players and the Game Master. (This task is identical to Task 19. The detailed "A to Z" description provided for Task 19 applies here.)
Result: A comprehensive and flexible logging and feedback formatting system capable of generating clear, detailed, and localized reports for players and GMs from any game event.

Task Block: Phase UI (User Interface)
Task 55: 🖥️ UI.1 UI Technology Stack Selection and Basic Structure.
Description: Select a framework/library for developing the client UI application (e.g., React, Vue, Svelte, Angular). Define the basic architecture of the UI application, including folder structure, state management approach (e.g., Redux, Zustand, Context API), routing, and API interaction layer. Set up the initial project with necessary build tools and linters. This task is foundational for all subsequent UI development.
Result: Chosen UI technology stack, initialized project structure, basic architectural guidelines.

Task 56: 🖥️ UI.2 Basic UI Structure and Authentication Development.
Description: **Backend**: Implement Discord OAuth2 login flow. Create API endpoints for `/auth/discord` (redirect to Discord), `/auth/discord/callback` (handle token exchange, create/update `MasterUser` (DB model: discord_id, username, avatar_url, accessible_guilds_json, last_login_at), generate JWT). Implement JWT middleware for securing UI-specific APIs. API `/auth/me/guilds` to list Master's accessible guilds (those where they are admin AND bot is present). API `/auth/session/active-guild` (POST to set, GET to retrieve active_guild_id in JWT session). **UI**: Create basic app layout (sidebar, header, content area). Implement login page redirecting to backend OAuth. Handle callback, store JWT securely (e.g., HttpOnly cookie or localStorage). Implement a guild selection page/dropdown using `/auth/me/guilds`. Store selected `active_guild_id` by calling `/auth/session/active-guild`. UI should send `active_guild_id` with all subsequent requests to guild-scoped API endpoints.
Result: Backend authentication is complete. UI has basic structure, login, and guild selection. All subsequent UI API calls can be authorized and scoped to the active guild.

Task 57: 🖥️ UI.3 UI for Player and Character Management.
Description: Create UI pages for viewing lists of Players and GeneratedNpcs for the selected guild (data via respective `/master_player list` and `/master_npc list` API calls, Task 47). Implement forms for creating, viewing details of, editing, and deleting Player and GeneratedNpc records (using `/master_player create/view/update/delete` and `/master_npc create/view/update/delete` APIs). Ensure UI correctly handles i18n fields for display and input (e.g., providing multiple text boxes for `name_i18n`).
Result: UI for managing players and NPCs.

Task 59: 🖥️ UI.5 UI for AI Generation and Moderation.
Description: **Full UI Implementation**: Create a comprehensive UI page/dashboard for managing AI content generation and moderation.
    - **Trigger Generation**: Form to call `/master_pending_generation trigger` (Task 2.6 / 47). Inputs: `entity_type` (dropdown: location, npc, item, quest, faction), `generation_context_json` (textarea, with client-side JSON validation), `location_id_context` (optional number input), `player_id_context` (optional number input). Display loading state and success/error notifications.
    - **List Pending Requests**: Table/list to display `PendingGeneration` records from `/master_pending_generation list`. Columns: ID, Requested Entity Type, Status (color-coded), Created At. Implement pagination and filtering by `status_filter`. Allow selection of a request to view details.
    - **View/Edit Details**: Modal or separate page to display full details of a selected `PendingGeneration` from `/master_pending_generation view`. Show: Trigger Context, Full AI Prompt, Raw AI Response, Parsed & Validated Data (nicely formatted JSON, perhaps in an editable tree view or form if schema is known for common types), Validation Issues (if any), Master Notes.
        - Allow editing `parsed_validated_data_json` (via textarea with JSON validation or structured form if feasible for known types) and `master_notes` (textarea). Saving these calls `/master_pending_generation update` and should set status to `EDITED_PENDING_APPROVAL`.
    - **Moderation Actions**: Buttons for "Approve" (`/master_pending_generation approve`), "Reject" (`/master_pending_generation update` with `new_status='REJECTED'`), and "Update/Save Edits" (already covered by edit logic for `/master_pending_generation update`).
    - Handle all loading states and provide clear user feedback (notifications for success/error).
Result: A fully functional UI for triggering, reviewing, editing, and approving/rejecting AI-generated content.

Task 60: 🖥️ UI.6 UI for Inventory and Item Management.
Description: **Full UI Implementation**: Create comprehensive UI pages for managing item definitions (`Item`) and entity inventories (`InventoryItem` for Players/NPCs).
    - **Item Definitions Management**:
        - List Page (`ItemListPage.tsx`): Display `Item` definitions (from `/master_item list`) with pagination. Columns: ID, Static ID, Name (primary lang), Type (primary lang), Base Value. Buttons to "Create New Item" and "Edit" existing.
        - Form (`ItemForm.tsx`): For creating/editing `Item` definitions (via `/master_item create/update`). Fields for `static_id`, `name_i18n_json` (e.g., textareas for each lang in `GuildConfig.supported_languages_json`), `description_i18n_json`, `item_type_i18n_json`, `item_category_i18n_json`, `base_value`, `is_stackable` (checkbox), `slot_type` (dropdown), `properties_json` (textarea with JSON validation). On edit, load data via `/master_item view`.
    - **Entity Inventory Management**:
        - Component to select entity: Dropdowns to select Player (from `/master_player list`) or NPC (from `/master_npc list`) to manage their inventory.
        - View Inventory (`EntityInventoryView.tsx`): Display `InventoryItem` list (from `/master_player view include_inventory=true` or `/master_npc view include_inventory=true`). Columns: Item Name (primary lang, from enriched data), Quantity, Equipped Status, custom properties preview. Buttons for "Edit Instance", "Delete Instance", "Equip/Unequip".
        - Add Item to Inventory Form (`AddItemToInventoryForm.tsx`): Select an `Item` definition (dropdown populated from `/master_item list`), input quantity, `instance_specific_properties_json` (opt. textarea). Calls `/master_inventory_item create`.
        - Edit Inventory Item Form (`EditInventoryItemForm.tsx`): For selected `InventoryItem`. Edit `quantity`, `instance_specific_properties_json`. Calls `/master_inventory_item update`.
        - Equip/Unequip logic calls `/master_inventory_item update` to change `equipped_status`.
    - **Dashboard (`ItemManagementDashboard.tsx`)**: Main page to navigate between Item Definition list/forms and Entity Inventory management sections.
    - Handle loading states and user feedback.
Result: UI for full CRUD of item definitions and management of items within player/NPC inventories.

Task 61: 🖥️ UI.7 UI for Faction and Relationship Management.
Description: **Full UI Implementation**: Create UI pages for managing Factions (`GeneratedFaction`) and Relationships (`Relationship`).
    - **Faction Management**:
        - List Page: Display Factions (from `/master_faction list`) with pagination. Columns: ID, Static ID, Name (primary lang), Leader NPC Name (if available). Buttons for "Create New Faction", "Edit".
        - Form: For creating/editing Factions (via `/master_faction create/update`). Fields for `static_id`, `name_i18n_json`, `description_i18n_json`, `ideology_i18n_json`, `leader_npc_static_id` (can be dropdown from NPCs), `resources_json`, `ai_metadata_json`. On edit, load from `/master_faction view`.
    - **Relationship Management**:
        - List Page: Display Relationships (from `/master_relationship list`) with pagination and filters (by entity1_id/type, entity2_id/type, relationship_type). Columns: ID, Entity1 (Name/Type), Entity2 (Name/Type), Relationship Type, Value. Buttons for "Create New Relationship", "Edit".
        - Form: For creating/editing Relationships (via `/master_relationship create/update`). Fields for `entity1_id`, `entity1_type` (dropdown), `entity2_id`, `entity2_type` (dropdown), `relationship_type` (dropdown or text), `value` (number input). On edit, load from `/master_relationship view`. Entity ID inputs could be enhanced with search/selection components.
    - Handle loading states and user feedback.
Result: UI for managing factions and inter-entity relationships.

Task 62: 🖥️ UI.8 UI for Quest Management.
Description: **Full UI Implementation**: Create UI pages for comprehensive management of Questlines, GeneratedQuests, QuestSteps, and PlayerQuestProgress.
    - **Questline Management**: List, Create, Edit, Delete Questlines (using `/master_quest questline_*` commands). Form fields: `static_id`, `title_i18n_json`, `description_i18n_json`, `starting_quest_static_id`, `is_main_storyline`, `required_previous_questline_static_id`, `properties_json`.
    - **GeneratedQuest Management**: List (filterable by Questline), Create, Edit, Delete GeneratedQuests (using `/master_quest generated_quest_*` commands). Form fields: `static_id`, `title_i18n_json`, `description_i18n_json`, `questline_id` (selector), `giver_entity_type/id`, `min_level`, `is_repeatable`, `rewards_json`, `properties_json`, `ai_metadata_json`.
    - **QuestStep Management (within a Quest context)**: List (for a selected GeneratedQuest), Create, Edit, Delete QuestSteps (using `/master_quest quest_step_*` commands). Form fields: `step_order`, `title_i18n_json`, `description_i18n_json`, `required_mechanics_json`, `abstract_goal_json`, `consequences_json`, `next_step_order`, `properties_json`.
    - **PlayerQuestProgress Management**: List (filterable by Player, Party, Quest, Status), View details, Create (manually assign quest), Edit (status, current_step_id, progress_data_json), Delete progress entries (using `/master_quest progress_*` commands).
    - Implement clear navigation between these entities (e.g., view Questline -> view its Quests -> view a Quest's Steps).
Result: UI for detailed management of all aspects of the quest system.

Task 63: 🖥️ UI.9 UI for Global Entity Management.
Description: **Full UI Implementation**: Create UI pages for managing GlobalNpcs and MobileGroups.
    - **GlobalNpc Management**: List, Create, Edit, Delete GlobalNpcs (using `/master_global_npc *` commands). Form fields: `static_id`, `name_i18n_json`, `description_i18n_json`, `npc_template_id` (selector from GeneratedNpcs), `current_location_id` (selector), `mobile_group_id` (selector), `route_json`, `properties_json`, `ai_metadata_json`.
    - **MobileGroup Management**: List, Create, Edit, Delete MobileGroups (using `/master_mobile_group *` commands). Form fields: `static_id`, `name_i18n_json`, `description_i18n_json`, `current_location_id`, `leader_global_npc_id` (selector), `members_definition_json` (complex field, possibly table input or JSON textarea), `behavior_type_i18n_json`, `route_json`, `properties_json`.
Result: UI for managing global NPCs and mobile groups.

Task 64: 🖥️ UI.10 UI for Monitoring and Logging.
Description: **Full UI Implementation**: Create UI pages for monitoring game state and logs.
    - **WorldState Viewer**: Page to list (`/master_monitor worldstate list` with prefix filter) and view (`/master_monitor worldstate get`) `RuleConfig` entries typically prefixed with "worldstate:". Display key, value (formatted JSON), description. (Essentially a filtered view of Task 58 UI).
    - **StoryLog Viewer**: Page to list (`/master_monitor log list` with filters for event_type, entity_ids_json, pagination) and view details (`/master_monitor log view`) of `StoryLog` entries. Display timestamp, event type, involved entities (names if possible by fetching from other services), formatted details.
    - **Map Viewer**: Page to display game locations visually (e.g., a grid or graph).
        - Fetch all locations (`/master_monitor map list_locations`).
        - Display location names, types. Click to view details (`/master_monitor map view_location`).
        - Optionally, overlay Players, NPCs, Global Entities by fetching their `current_location_id` (from `/master_player list`, `/master_npc list`, `/master_global_npc list`, `/master_mobile_group list`).
Result: UI for monitoring game state, viewing event logs, and visualizing the game map with entity locations.

Task 65: 🖥️ UI.11 UI for Balance Tools.
Description: **Full UI Implementation**: Create UI pages to interact with balance and testing tools.
    - **Main Page with Tabs**: "Simulate Check", "Simulate Combat Action", "Simulate Conflict", "Analyze AI Generation".
    - **Simulate Check Tab**: Form with inputs for `/master_simulate check` parameters (`check_type`, `actor_id/type`, `target_id/type`, `difficulty_dc`, `json_context`). Display detailed `IUICheckResult`.
    - **Simulate Combat Action Tab**: Form for `/master_simulate combat_action` (`combat_encounter_id`, `actor_id/type`, `action_json_data`, `dry_run` checkbox). Display `UICombatActionResult` and updated participant states if returned.
    - **Simulate Conflict Tab**: Form for `/master_simulate conflict_detection` (`actions_json` textarea). Display list of `UIPydanticConflictForSim`.
    - **Analyze AI Generation Tab**: Form for `/master_analyze ai_generation` (`entity_type` dropdown, `generation_context_json`, `target_count`, `use_real_ai` checkbox). Display `UIAiAnalysisResult`, particularly the list of `UIEntityAnalysisReport` with issues and scores.
Result: UI for accessing and interpreting results from backend balance and testing simulation tools.

Task 66: 🖥️ UI.12 UI for Conflict Resolution.
Description: **Full UI Implementation**: Create UI pages for manually resolving action conflicts.
    - **Conflict List Page (`ConflictListPage.tsx`)**: Display `PendingConflict` items (from `/master_conflict list` with status filter, pagination). Columns: ID, Status, Created At, Involved Entities Summary. Allow selection to view details.
    - **Conflict Detail Page (`ConflictDetailPage.tsx`)**: For a selected conflict (from `/master_conflict view`). Display full `UIConflictDetails`: involved entities actions (formatted `ParsedAction`), conflicting actions, current status, resolution notes.
        - Provide controls to resolve: Dropdown for `outcome_status` (populated from `UIConflictStatus` values like `RESOLVED_BY_MASTER_FAVOR_ACTION1`, etc., with localized names). Textarea for `notes`. Submit button calls `/master_conflict resolve`.
    - **Dashboard (`ConflictResolutionPage.tsx`)**: Orchestrates list and detail views.
Result: UI for Masters to review and manually resolve pending action conflicts.

Task 67: 🖥️ UI.13 Backend API for Command List.
Description: Develop a backend API endpoint that provides structured information about bot commands. This API will be used by the UI (Task 68) to display a helpful command list or guide.
The API should return: Command name (including group/subgroup), description, parameters (name, description, type, required). Support localization if command descriptions are localized.
API Endpoint: `GET /api/v1/command-list/`
Response Model: `CommandListResponse` (contains list of `CommandInfo`). `CommandInfo` contains `name`, `description`, list of `CommandParameterInfo`.
Result: Backend API providing structured bot command information.

Task 68: 🖥️ UI.14 UI "Command List" Section (Help/Guide).
Description: **Full UI Implementation**: Create a UI section/page to display the list of available bot commands, using the API from Task 67.
    - Fetch command data from `/api/v1/command-list/` (optionally with language parameter).
    - Display commands grouped by category (if discernible from command names or an added field).
    - For each command, show: Name, Description, Parameters (Name, Type, Required, Description).
    - Allow searching/filtering commands by name or keyword.
    - Ensure clear and user-friendly presentation.
Result: A helpful UI guide listing all bot commands for users and Masters.
... (UI Tasks 55-68 Descriptions will remain as is, as they describe UI work based on backend capabilities. The "A to Z" focus is on the backend tasks that enable these UIs.)
