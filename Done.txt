ðŸ”§ 0.1 Discord Bot Project Initialization and Basic Guild Integration.
Description: Set up the Python project structure using the chosen asynchronous framework. Initialize integration with the Discord API, handle basic Discord events (on_ready, on_message, on_guild_join, on_guild_remove). Configure logging. Implement utility commands (e.g., /ping).
Result: Basic working Discord bot, configured for multiple guilds, logging, language system (language system part will be addressed in later tasks).

Key achievements for this task:
- Project structure created (src, tests, config, bot directories).
- Core files created: main.py, bot/core.py, bot/events.py, bot/commands.py, config/settings.py, requirements.txt, .gitignore.
- BotCore class implemented with setup_hook for loading cogs.
- EventCog implemented with on_ready, on_message, on_guild_join, on_guild_remove, on_command_error handlers.
- CommandCog implemented with a /ping command.
- Logging configured, level settable via environment variable.
- Basic .env file structure mentioned in settings.py.
- requirements.txt includes discord.py and python-dotenv.

---

ðŸ’¾ 0.2 DBMS Setup and Database Model Definition with Guild ID.
Description: Select a scalable DBMS (PostgreSQL/MySQL) and ORM. Define the structure of all data models in the DB. Crucial: All models storing game data specific to a particular guild MUST INCLUDE a guild_id field (BIGINT, Indexed) as part of a composite key or FK to GuildConfig). (Field details are in task descriptions where these models are detailed: Player, Location, WorldState, Party, GeneratedNpc, GeneratedFaction, GeneratedQuest, Item, Inventory, Log, Relationship, PlayerNpcMemory, RuleConfig, Ability, Skill, Status, ItemProperty, Questline, QuestStep, MobileGroup, CraftingRecipe). Text fields - JSONB (_i18n).
Implement the GuildConfig model: id (PK, BIGINT - the Discord guild's ID itself), master_channel_id (BIGINT), system_channel_id (BIGINT), notification_channel_id (BIGINT, for moderation/conflict notifications), main_language (TEXT).
Configure ORM and migrations.
Result: DB schema is ready for full data isolation by guild and storing all types of game data with multilingual support.

Key achievements for this task:
- Defined `Base` model and `GuildConfig` model using SQLAlchemy in `src/models/`.
- Added `SQLAlchemy`, `asyncpg`, `alembic` to `requirements.txt`.
- Configured database connection settings (`DATABASE_URL`) in `src/config/settings.py`.
- Created `src/core/database.py` with async engine, session factory, and `init_db` / `get_db_session` functions.
- Integrated `init_db` into `main.py` for initial table creation.
- Initialized and configured Alembic for database migrations:
    - `alembic.ini` and `alembic/env.py` modified for project structure and async operations.
    - First migration for `GuildConfig` created (manually due to sandbox limitations).
- Project is now set up for database interaction with PostgreSQL using SQLAlchemy and Alembic.

---

ðŸ”§ 0.3 Basic DB Interaction Utilities and Rule Configuration Access (Guild-Aware).
Description: Implement low-level functions for working with the DB that always operate within the context of the specified guild.
Implement utilities for managing ORM sessions (get_db_session). Implement decorators or context managers for managing ORM TRANSACTIONS (@transactional(guild_id)). These transactions MUST operate ONLY WITH DATA WITHIN THE SPECIFIED guild_id.
Implement CRUD utilities (get_entity_by_id, create_entity, update_entity, delete_entity) for ALL models. These utilities MUST accept guild_id as the FIRST mandatory parameter and AUTOMATICALLY add the condition WHERE guild_id = :guild_id to queries.
Implement the load_rules_config(guild_id: int) -> dict utility: Loads all RuleConfig records (0.2) for the specified guild and forms a rules dictionary. Caches this dictionary per-guild in the bot process memory.
Implement the get_rule(guild_id: int, key: str) -> Any utility: Retrieves a rule parameter FROM THE CACHE for the specified guild by key. Handle errors.
Implement the update_rule_config(guild_id: int, key: str, value: Any) utility: Updates the RuleConfig in the DB for the specified guild. After successful saving, updates the cache for this guild (load_rules_config).
Result: A set of utilities for reliable, secure (guild-isolated) DB data access and configurable rules.

Key achievements for this task:
- Defined `RuleConfig` model in `src/models/rule_config.py` with `guild_id`, `key`, `value_json` and unique constraint on `(guild_id, key)`.
- Created Alembic migration `0002_create_rule_configs_table.py` for `RuleConfig`.
- Implemented `@transactional` decorator in `src/core/database.py` for managing DB transaction lifecycle using `get_db_session`.
- Created `src/core/crud.py` with:
    - `CRUDBase` generic class for common CRUD operations.
    - Generic functions `create_entity`, `get_entity_by_id`, `update_entity`, `delete_entity` that are guild-aware.
- Created `src/core/rules.py` with:
    - `load_rules_config_for_guild`: Loads all rules for a guild into an in-memory cache (`_rules_cache`).
    - `get_rule`: Retrieves a rule from cache (or loads if not present).
    - `update_rule_config`: Updates/creates a rule in DB and refreshes the guild's cache.
    - `get_all_rules_for_guild`: Retrieves all rules for a guild from cache.
- Updated `src/models/__init__.py` and `src/core/__init__.py` to include new modules and models.
