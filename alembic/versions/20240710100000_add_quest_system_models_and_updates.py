"""Add quest system models and updates

Revision ID: 20240710100000
Revises: <РЕВИЗИЯ_ПРЕДЫДУЩЕЙ_МИГРАЦИИ>
Create Date: 2024-07-10 10:00:00.000000

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '20240710100000'
down_revision: Union[str, None] = '<РЕВИЗИЯ_ПРЕДЫДУЩЕЙ_МИГРАЦИИ>' # Заполнить ID предыдущей миграции
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# Определяем тип JSONB для PostgreSQL и TEXT для других (например, SQLite)
JsonBType = sa.JSON()
if op.get_bind().dialect.name == 'postgresql':
    JsonBType = postgresql.JSONB(astext_type=sa.Text())

TimestampType = sa.TIMESTAMP(timezone=True)


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # Questlines Table
    op.add_column('questlines', sa.Column('created_at', TimestampType, server_default=sa.text('now()'), nullable=False))
    op.add_column('questlines', sa.Column('updated_at', TimestampType, server_default=sa.text('now()'), nullable=False)) # onupdate will be handled by SQLAlchemy model
    op.alter_column('questlines', 'name_i18n', new_column_name='title_i18n', existing_type=JsonBType, nullable=False, existing_server_default=sa.text("'{}'::jsonb"))
    op.add_column('questlines', sa.Column('starting_quest_static_id', sa.Text(), nullable=True))
    op.add_column('questlines', sa.Column('is_main_storyline', sa.Boolean(), nullable=False, server_default=sa.false()))
    op.add_column('questlines', sa.Column('required_previous_questline_static_id', sa.Text(), nullable=True))
    op.add_column('questlines', sa.Column('properties_json', JsonBType, nullable=True, server_default=sa.text("'{}'::jsonb")))

    # GeneratedQuests Table
    op.add_column('generated_quests', sa.Column('created_at', TimestampType, server_default=sa.text('now()'), nullable=False))
    op.add_column('generated_quests', sa.Column('updated_at', TimestampType, server_default=sa.text('now()'), nullable=False)) # onupdate will be handled by SQLAlchemy model
    op.add_column('generated_quests', sa.Column('is_repeatable', sa.Boolean(), nullable=False, server_default=sa.false()))
    op.add_column('generated_quests', sa.Column('properties_json', JsonBType, nullable=True, server_default=sa.text("'{}'::jsonb")))

    # QuestSteps Table
    op.add_column('quest_steps', sa.Column('created_at', TimestampType, server_default=sa.text('now()'), nullable=False))
    op.add_column('quest_steps', sa.Column('updated_at', TimestampType, server_default=sa.text('now()'), nullable=False)) # onupdate will be handled by SQLAlchemy model
    op.add_column('quest_steps', sa.Column('next_step_order', sa.Integer(), nullable=True))
    op.add_column('quest_steps', sa.Column('properties_json', JsonBType, nullable=True, server_default=sa.text("'{}'::jsonb")))

    # PlayerQuestProgress Table
    op.add_column('player_quest_progress', sa.Column('created_at', TimestampType, server_default=sa.text('now()'), nullable=False))
    op.add_column('player_quest_progress', sa.Column('updated_at', TimestampType, server_default=sa.text('now()'), nullable=False)) # onupdate will be handled by SQLAlchemy model
    op.add_column('player_quest_progress', sa.Column('party_id', sa.Integer(), nullable=True))
    op.add_column('player_quest_progress', sa.Column('accepted_at', TimestampType, nullable=True))
    op.add_column('player_quest_progress', sa.Column('completed_at', TimestampType, nullable=True))

    op.alter_column('player_quest_progress', 'player_id', existing_type=sa.INTEGER(), nullable=True)

    op.create_foreign_key('fk_player_quest_progress_party_id', 'player_quest_progress', 'parties', ['party_id'], ['id'], ondelete='CASCADE')

    # Rename existing UniqueConstraint uq_player_quest -> uq_player_quest_guild
    # This might fail if the constraint name is different or auto-generated. Manual check might be needed.
    # op.drop_constraint('uq_player_quest', 'player_quest_progress', type_='unique') # If needed
    op.create_unique_constraint('uq_player_quest_guild', 'player_quest_progress', ['guild_id', 'player_id', 'quest_id'])

    op.create_unique_constraint('uq_party_quest_guild', 'player_quest_progress', ['guild_id', 'party_id', 'quest_id'])
    op.create_check_constraint('cc_player_or_party_id_not_null', 'player_quest_progress', 'player_id IS NOT NULL OR party_id IS NOT NULL')

    op.create_index('ix_player_quest_progress_party_id', 'player_quest_progress', ['party_id'], unique=False) # Index for party_id FK
    op.create_index('ix_player_quest_progress_player_quest', 'player_quest_progress', ['player_id', 'quest_id'], unique=False)
    op.create_index('ix_player_quest_progress_party_quest', 'player_quest_progress', ['party_id', 'quest_id'], unique=False)

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # PlayerQuestProgress Table (reverse order of creation)
    op.drop_index('ix_player_quest_progress_party_quest', table_name='player_quest_progress')
    op.drop_index('ix_player_quest_progress_player_quest', table_name='player_quest_progress')
    op.drop_index('ix_player_quest_progress_party_id', table_name='player_quest_progress')

    op.drop_constraint('cc_player_or_party_id_not_null', 'player_quest_progress', type_='check')
    op.drop_constraint('uq_party_quest_guild', 'player_quest_progress', type_='unique')

    op.drop_constraint('uq_player_quest_guild', 'player_quest_progress', type_='unique')
    # op.create_unique_constraint('uq_player_quest', 'player_quest_progress', ['guild_id', 'player_id', 'quest_id']) # Restore old one if needed

    op.drop_constraint('fk_player_quest_progress_party_id', 'player_quest_progress', type_='foreignkey')

    op.alter_column('player_quest_progress', 'player_id', existing_type=sa.INTEGER(), nullable=False) # Assuming it was False before

    op.drop_column('player_quest_progress', 'completed_at')
    op.drop_column('player_quest_progress', 'accepted_at')
    op.drop_column('player_quest_progress', 'party_id')
    op.drop_column('player_quest_progress', 'updated_at')
    op.drop_column('player_quest_progress', 'created_at')

    # QuestSteps Table
    op.drop_column('quest_steps', 'properties_json')
    op.drop_column('quest_steps', 'next_step_order')
    op.drop_column('quest_steps', 'updated_at')
    op.drop_column('quest_steps', 'created_at')

    # GeneratedQuests Table
    op.drop_column('generated_quests', 'properties_json')
    op.drop_column('generated_quests', 'is_repeatable')
    op.drop_column('generated_quests', 'updated_at')
    op.drop_column('generated_quests', 'created_at')

    # Questlines Table
    op.drop_column('questlines', 'properties_json')
    op.drop_column('questlines', 'required_previous_questline_static_id')
    op.drop_column('questlines', 'is_main_storyline')
    op.drop_column('questlines', 'starting_quest_static_id')
    op.alter_column('questlines', 'title_i18n', new_column_name='name_i18n', existing_type=JsonBType, nullable=False, existing_server_default=sa.text("'{}'::jsonb"))
    op.drop_column('questlines', 'updated_at')
    op.drop_column('questlines', 'created_at')

    # ### end Alembic commands ###
