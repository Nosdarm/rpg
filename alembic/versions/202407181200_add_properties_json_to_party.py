"""add properties_json to party

Revision ID: 202407181200
Revises: c3a08c4dbe7e
Create Date: 2024-07-18 12:00:00.000000

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql # Keep for potential future use if DB changes
# Assuming custom_types.py is directly under src or accessible via python path
# For alembic context, it's often better to define types like JsonBForSQLite
# in a way that alembic can import it, or use sqlalchemy.JSON directly if sufficient.
# If JsonBForSQLite is just sqlalchemy.JSON, then use that.
# For this example, I'll assume direct sa.JSON is okay for alembic,
# or that JsonBForSQLite is properly configured in env.py for alembic.
# If not, alembic might default to a TEXT type on SQLite if it can't resolve JsonBForSQLite.
# For broader compatibility and if JsonBForSQLite is complex:
try:
    from src.models.custom_types import JsonBForSQLite
except ImportError:
    # Fallback or simplified type for Alembic if direct import fails
    # This is a common pattern if src is not in PYTHONPATH for alembic runs easily
    JsonBForSQLite = sa.JSON


# revision identifiers, used by Alembic.
revision: str = '202407181200'
down_revision: Union[str, None] = 'c3a08c4dbe7e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('parties', sa.Column('properties_json', JsonBForSQLite(), nullable=True, server_default=sa.text("'{}'::jsonb"))) # Using ::jsonb for PostgreSQL
    # For SQLite, server_default=sa.text("'{}'") would be more appropriate if JsonBForSQLite handles it.
    # Given it's JsonBForSQLite, it might be designed for SQLite's JSON handling.
    # Let's adjust server_default for SQLite if that's the primary target.
    # bind = op.get_bind()
    # if bind.engine.name == "sqlite":
    #     op.add_column('parties', sa.Column('properties_json', JsonBForSQLite(), nullable=True, server_default=sa.text("'{}'")))
    # else: # Assuming PostgreSQL or similar that supports ::jsonb
    #     op.add_column('parties', sa.Column('properties_json', JsonBForSQLite(), nullable=True, server_default=sa.text("'{}'::jsonb")))
    # Simpler: Use sa.JSON for alembic which should be cross-DB, actual type handled by custom_types.py in app
    # op.add_column('parties', sa.Column('properties_json', sa.JSON(), nullable=True, server_default=sa.text("'{}'")))

    # Final decision: Rely on JsonBForSQLite to be correctly interpreted or handled by env.py
    # The server_default should be dialect-agnostic if possible, or use dialect specific blocks.
    # For JSON, '{}' is a common default. The ::jsonb cast is PG specific.
    # If JsonBForSQLite uses TEXT on SQLite, then '{}' is fine.
    # Let's use a generic string default that should work for JSON text.
    op.add_column('parties', sa.Column('properties_json', JsonBForSQLite(), nullable=True, server_default=sa.text("'{}'")))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('parties', 'properties_json')
    # ### end Alembic commands ###
