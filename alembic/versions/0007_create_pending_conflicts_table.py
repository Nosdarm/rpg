"""Create pending_conflicts table and conflict_status_enum

Revision ID: 0007
Revises: 0006
Create Date: YYYY-MM-DD HH:MM:SS.SSSSSS # Placeholder for actual date

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '0007'
down_revision: Union[str, None] = '0006'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# Enum definition for ConflictStatus
conflict_status_enum = postgresql.ENUM(
    'PENDING_MASTER_RESOLUTION',
    'RESOLVED_AUTOMATICALLY_CONTINUE',
    'RESOLVED_AUTOMATICALLY_REJECT',
    'RESOLVED_BY_MASTER_APPROVED',
    'RESOLVED_BY_MASTER_REJECTED',
    'EXPIRED',
    name='conflict_status_enum',
    create_type=False  # Will be created explicitly if it doesn't exist
)

def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Create conflict_status_enum type if it doesn't exist
    # Usually, enums are created when the first table using them is created,
    # or they can be managed separately. Here we ensure it's available.
    # If it was already created by a model definition (e.g. via SQLAlchemy metadata.create_all),
    # this might not be strictly necessary, but good for standalone migration.
    # However, SQLAlchemy's default behavior is to create it with the table.
    # For safety, we can use op.execute to create if not exists, or rely on table creation.
    # Let's assume the Enum type will be created by the table definition below.

    # If the enum type is not automatically created by SQLAlchemy with the table,
    # or if you need to ensure it exists before table creation for some reason:
    # op.execute("CREATE TYPE conflict_status_enum AS ENUM ('PENDING_MASTER_RESOLUTION', ...)")
    # For now, we'll rely on SQLAlchemy to handle its creation with the table column.
    # If `create_type=False` was used in Python model, then we MUST create it here.
    # The Python model had create_type=False, so we must create it.
    conflict_status_enum.create(op.get_bind(), checkfirst=True)

    op.create_table('pending_conflicts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('guild_id', sa.BigInteger(), nullable=False),
    sa.Column('involved_entities_json', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('conflicting_actions_json', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('status', conflict_status_enum, nullable=False),
    sa.Column('resolution_notes', sa.Text(), nullable=True),
    sa.Column('resolved_action_json', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('resolved_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['guild_id'], ['guild_configs.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_pending_conflicts_guild_id'), 'pending_conflicts', ['guild_id'], unique=False)
    op.create_index(op.f('ix_pending_conflicts_id'), 'pending_conflicts', ['id'], unique=False)
    op.create_index(op.f('ix_pending_conflicts_status'), 'pending_conflicts', ['status'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_pending_conflicts_status'), table_name='pending_conflicts')
    op.drop_index(op.f('ix_pending_conflicts_id'), table_name='pending_conflicts')
    op.drop_index(op.f('ix_pending_conflicts_guild_id'), table_name='pending_conflicts')
    op.drop_table('pending_conflicts')

    # Drop the enum type
    conflict_status_enum.drop(op.get_bind(), checkfirst=True)
    # ### end Alembic commands ###
